# Recoding Variables

Today's venture concerns univariate analysis, i.e. the quantitative description of a single variable. Before we do that, however, we need to familiarize ourselves with some data-cleaning procedures. 

## Background
Recoding a variable involves manipulating the underlying structure of our variable such that we can use it for analysis. We did a little recoding during the last unit when we converted character vectors into factor variables. This allowed us to align R data types with the appropriate level of measurement.

There are also occasions when we need a variable to be translated from one level of measurement to another. For example, we may want to convert a ratio variable for "number of years of education" into an ordinal variable reflecting categories like "less than high school", "high school diploma", "Associates degree", and so on. 

We may also want to collapse the categories of ordinal variables for some analyses. Consider a variable with a Likert-scale agreement rating, where you responses like "strongly agree," "moderately agree," "slightly agree," and so forth. You may decide to collapse these categories into categories of "Agree" and "Disagree". 

We will get some practice doing this sort of thing, which is an essential component of responsible analysis. Additionally, our next unit on bivariate analysis will require us to work with categorical variables in particular, so we need to be capable of converting any numeric variables.

## Converting Numeric to Categorical
We will start by recoding `age`---a ratio variable---into an ordinal variable reflecting age groupings. The same strategies we use here will work for any numeric variable. 

As usual, let's make sure we load in `tidyverse` along with our GSS data.
```{r, message=FALSE, warning=FALSE}
library(tidyverse)
load("our_gss.rda")
```

Let's double check the structure of our data frame.
```{r}
str(our_gss)
```
::: {.callout-note}
You might notice the 'int' category, which is short for 'integer'. This is a subtype of numeric data in R. Variables that are exclusively whole numbers are often recorded in this way, but we can work with them in R just like we can other sorts of numbers
:::

We can take a look at all the values of age (along with the # of respondents in each age category) using the `count()` function. 
```{r, eval=FALSE}
count(our_gss, age)
```
However, I'm not going to display those results here, as it will be a particularly long table of values (with 70+ different ages). It's fine to run it---it won't crash R or anything---but it will it clutter up this page. Let's take this as a good opportunity to take advantage of the fact that we are using one of the better funded and well-organized surveys in all of social sciences. As such, there's extensive documentation about all of the variables measured for the GSS. [Go ahead and take a look at the age variable via the GSS Data Explorer](https://gssdataexplorer.norc.org/variables/53/vshow), which allows us to search for unique variables and view their response values, the specific question(s) that was asked on the survey, and several other variable characteristics. 

The responses range from 18 - 89 (in addition to a few categories for non-response). However, note that there's something unique about value 89. It's not just 89 years of age, but 89 & older. This isn't a real issue for our purposes, but take this as encouragement to interface with the codebook of any publicly available data you use. There's some imprecision at the upper end of this variable, and that might not be obvious without referencing the codebook.

For the purposes of this exercise, let's go ahead and turn age into a simple categorical variable with 3 levels---older, middle age, and younger. I'm going to choose the range somewhat arbitrarily for now. We can use univariate analysis to inform our decision about how to break up a numeric variable, so we will revisit this idea again later on.

-   *Younger* = 18 - 35
-   *Middle Age* = 36 - 49
-   *Older* = 50 and up

Let's go ahead and actualize this scheme. First, let's consider the `mutate()` function. This function takes a data frame and outputs a new variable that is calculated by way of some transformation applied to an existing column. 

Now, this wouldn't be the best idea for a couple reasons, but, as an illustration, let's say we wanted to convert our yearly income values to an hourly wage (assuming 40 hrs/week).

`mutate()` takes a data frame as its input, and then we provide the name of our new variable column(s) along with the calculation for this new variable. Below, I use `mutate()` to create a new column called `hr_wage` which is the result of taking each person's income and dividing that by 52 weeks in a year, and then 40 hours in a week. 

```{r}
our_gss <- our_gss |>
  mutate(
    hr_wage = (realrinc/52)/40
  )
```








