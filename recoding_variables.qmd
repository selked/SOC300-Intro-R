# Recoding Variables

Today's venture concerns univariate analysis, i.e. the quantitative description of a single variable. Before we do that, however, we need to familiarize ourselves with some data-cleaning procedures. 

## Background
Recoding a variable involves manipulating the underlying structure of our variable such that we can use it for analysis. We did a little recoding during the last unit when we converted character vectors into factor variables. This allowed us to align R data types with the appropriate level of measurement.

There are also occasions when we need a variable to be translated from one level of measurement to another. For example, we may want to convert a ratio variable for "number of years of education" into an ordinal variable reflecting categories like "less than high school", "high school diploma", "Associates degree", and so on. 

We may also want to collapse the categories of ordinal variables for some analyses. Consider a variable with a Likert-scale agreement rating, where you responses like "strongly agree," "moderately agree," "slightly agree," and so forth. You may decide to collapse these categories into categories of "Agree" and "Disagree". 

We will get some practice doing this sort of thing, which is an essential component of responsible analysis. Additionally, our next unit on bivariate analysis will require us to work with categorical variables in particular, so we need to be capable of converting any numeric variables.

## Converting Numeric to Categorical
We will start by recoding `age`---a ratio variable---into an ordinal variable reflecting age groupings. The same strategies we use here will work for any numeric variable. 

### Setting up our workspace

As usual, let's make sure we load in `tidyverse` along with our GSS data.
```{r, message=FALSE, warning=FALSE}
library(tidyverse)
load("our_gss.rda")
```

Let's double check the structure of our data frame.
```{r}
str(our_gss)
```
::: {.callout-note}
You might notice the 'int' category, which is short for 'integer'. This is a subtype of numeric data in R. Variables that are exclusively whole numbers are often recorded in this way, but we can work with them in R just like we can other sorts of numbers
:::

### The 'age' variable

We can take a look at all the values of age (along with the # of respondents in each age category) using the `count()` function. 
```{r, eval=FALSE}
count(our_gss, age)
```
However, I'm not going to display those results here, as it will be a particularly long table of values (with 70+ different ages). It's fine to run it---it won't crash R or anything---but it will it clutter up this page. Let's take this as a good opportunity to take advantage of the fact that we are using one of the better funded and well-organized surveys in all of social sciences. As such, there's extensive documentation about all of the variables measured for the GSS. [Go ahead and take a look at the age variable via the GSS Data Explorer](https://gssdataexplorer.norc.org/variables/53/vshow), which allows us to search for unique variables and view their response values, the specific question(s) that was asked on the survey, and several other variable characteristics. 

The responses range from 18 - 89 (in addition to a few categories for non-response). However, note that there's something unique about value 89. It's not just 89 years of age, but 89 & older. This isn't a real issue for our purposes, but take this as encouragement to interface with the codebook of any publicly available data you use. There's some imprecision at the upper end of this variable, and that might not be obvious without referencing the codebook.

For the purposes of this exercise, let's go ahead and turn age into a simple categorical variable with 3 levels---older, middle age, and younger. I'm going to choose the range somewhat arbitrarily for now. We can use univariate analysis to inform our decision about how to break up a numeric variable, so we will revisit this idea again later on.

-   **Younger** = 18 - 35
-   **Middle Age** = 36 - 49
-   **Older** = 50 and up

At the end of the day, what we need to do is 1.) create a new variable column 2.) populate that column with ordinal labels that correspond with each respondent's numeric age interval.

### New columns with mutate()
First, let's consider the `mutate()` function. This function takes a data frame and appends a new variable column. This new variable is the result of some calculation applied to an existing variable column.  

Let's look at an application fo `mutate()` to get a feel for it. Now, this wouldn't be the best idea for a couple reasons, but, as an illustration, let's say we wanted to convert our yearly income values to an hourly wage (assuming 40 hrs/week).

`mutate()` takes a data frame as its input, and then we provide the name of our new variable column(s) along with the calculation for this new variable. Below, I use `mutate()` to create a new column called `hr_wage`. Then, I tell R that the `hr_wage` variable should be calculated by taking each person's income value and diving that by 52 weeks in a year, and then 40 hours in a week.

```{r}
# Without the pipe operator
our_gss <- mutate(
  our_gss,
  hr_wage = (realrinc/52)/40
  )
```
```{r, eval=FALSE}
# With the pipe operator
our_gss <- our_gss |>
  mutate(
    hr_wage = (realrinc/52)/40
  )
```

Take a look at your new data frame object. I'll show a summary here to verify that we got our new column.

```{r}
summary(our_gss)
```

So, we can use `mutate()` to add a new column that contains our recoded variable. We just need a way to specify a calculation that takes into account the specific intervals we want for our ordinal labels. For this, we need one more function.

### Custom intervals with cut()

We can use the `cut()` function to specify the intervals we want for our age groupings, and then we will combine it with `mutate()` to generate our recoded age variable.

But first, I want to give a little context on interval notation in mathematics. It will help us all be a little more precise when we talk about ranges, and it will also help us understand an input we need to provide for `cut()`.

#### An aside on intervals
In mathematic terms, an interval is the set of all numbers in between two specified end points. In formal notation, these are indicated with the two endpoints placed in square brackets, e.g [1,5] as the interval of 1 through 5. 

There are some technical terms to describe whether or not we want to include the endpoints when we are talking about a particular interval.

- **Closed interval**: This is when both end points are included in the interval. Closedness is indicated with square brackets, so, the closed interval of 1 through 5 would be written just like I have above---[1,5]. This indicates any number 'x' where 1 <= x <= 5

- **Open interval**: This is when neither endpoint is included in the interval. In interval notation, openness is indicated with parentheses rather than square brackets, so the open interval of 1 through 5 would be written as (1,5). This interval would indicate any number 'x' where 1 < x < 5

- **Left-open interval**: This is when the left-hand endpoint is not included, but the right-hand endpoint is. This would be written as (1,5] in interval notation, and that interval would indicate any number 'x' where 1 < x <= 5

- **Right-open interval**: When the right-hand endpoint isn't included but the left endpoint is, you have a right-open interval. This would be written as [1,5) in interval notation and would indicate any number 'x' where 1 <= x < 5. 

We will be working with the right-open interval format, and we can specify that in `cut()`.

Now, let's return to our task at hand.

#### Inputs for cut()
We'll go ahead and work with cut directly in `mutate()`, as its going to be the calculation that we are providing for the new column we generate with `mutate()`. 

As a reminder, here are the intervals we need:

-   **Younger** = 18 - 35
-   **Middle Age** = 36 - 49
-   **Older** = 50 and up

The following code may look a little chaotic at first glance, but it's really the same sort of thing that we did with `mutate()` above. It's just that `cut()` is a little bit more involved of a calculation than the simple division we did in our example. 

Just like above, we are applying `mutate()` to `our_gss`, and we are giving the name of our new variable column (`age_ord`, in this case) as the first input. Then, for the calculation, we give the `cut()` function and the arguments it needs.

**cut() and its inputs**

-   The variable for which we want to specify intervals (`age`)

-   **breaks**: This is where we indicate the intervals. The first number we give is the low end of our lowest age group (18). The second number is the low end of our middle age group (36). The third number, as you probably guessed, is the low end of our highest age group. The last value should reflect our upper limit. In this case, I use the value `Inf`, which is short for 'infinity'. This essentially tells R that the last category can include any values higher than the previous number we entered. 

-   **include.lowest**: Putting `TRUE` here tells R that, in each interval, we want the lowest value to be included. If we don't do this, then our 'younger' age grouping would be 19 - 35 rather than 18 - 35. In other words, setting this to `TRUE` indicates a left-closed interval, and `FALSE` indicates a left-open interval.

-   **right**: This is the input for specifying whether we want this to be a right-closed interval, and it takes a logical value (`TRUE` or `FALSE`). We want a right-open interval, so we will set this to `FALSE`. 
-   **labels**: R will actually default to formal interval notation for the names of each level of our new factor variable, so it would be [18,36), [36,50), [50, Inf). However, we can provide a character vector to specify custom labels for these new factor levels. In the event that you have an ordinal variable, make sure that you always specify these labels in ascending order. In this case, that would be Younger < Middle Age < Older.

-   **ordered_result**: This takes a logical value and, as the name suggests, indicates whether we want the factor to be ordered or not. In our case, there is a clear progression in terms of age, so we need to set this to `TRUE`.


```{r}
our_gss <- our_gss |>
  mutate(
    age_ord = cut(
      age,
      breaks = c(18, 36, 51, Inf),
      include.lowest = TRUE,
      right = FALSE,
      labels = c("Younger", "Middle Age", "Older"),
      ordered_result = TRUE
    )
  )
```

Go ahead and take a look at `our_gss`, and our new column should bring us to 10 variables instead of 9. I'll display a summary here so we can check.

```{r}
summary(our_gss)
```









