# Publication Ready Visuals
In this last portion of our in-class lab sessions on quantitative analysis, we'll learn how to make some familiar visuals in new and exciting ways. For the most part, this will involve learning the graphing package of tidyverse, commonly known as `ggplot`. There are a couple of things to get used to with ggplot, but once you get a handle on its syntax, it will offer simple and extensive customizability that translates across a wide expanse of use cases. Even some of the graphics that we've seen in empirical papers for class have been produced using ggplot! 

## Setting up our workspace
Because ggplot comes with tidyverse, we just need to load in `tidyverse` like we've often done. We're also going to need `janitor`, and, as usual, we'll also pull in our GSS data.

```{r, warning = FALSE, message = FALSE}
library(tidyverse)
library(janitor)
load("our_gss.rda")
```

## Figures

Specific to categorical variables, we learned about two key plot-types: histograms and barplots. We'll start our foray into `ggplot` by using it to recreate some figures in these styles.

### Barplots & Basics of ggplot

The structure of figures made with ggplot is quite regular. The name 'ggplot' is actually a reference to the idea of a **g**rammar of **g**raphics, and though there are some specifics across the various plot types, we will offer ggplot mostly the same kind of information regardless.

First, ggplot expects that we will give it a dataframe. This is good because it also means that ggplot plays well with the pipe operator.

Next, ggplot needs input for your **aesthetic mappings**, shortened to `aes()` within the function. This might sound a little hoighty toighty, but it simply refers to the specification of some key parameters for our figure. We want our data to be visually mapped in a certain sort of way, and this is where we set that up. 

The simplest aesthetic mappings we can provide are the variables we want associated with the x & y columns. Let's try with `sex` as an example. Because we are making a barplot, our y-axis will reflect the frequency of the values of the y-axis.

We'll need to manually calculate this and add it to our data frame, which is thankfully simple enough.

```{r}
our_gss |>
  drop_na(sex) |>
  ggplot(
    aes(x = sex))
```
Now, you might be asking yourself: what's the deal? We only see the labels of the x-axis there.

The syntax of ggplot is often explained by making an analogy with paintings. You start by setting up a basic canvas with your `aes()` specifications, and then you add on different layers reflecting the shape of your data and various customizations to its appearance. 

The first layer we typically add is a **geometric object** specification---shorted to `geom` in ggplot language. You can think of this as the place where you tell ggplot what kind of figure you want. There are a great many geoms, and you can read more about the full extent of them [here](https://ggplot2.tidyverse.org/reference/index.html). 

In our case, we want a barplot, so we can add `geom_bar()` as an additional layer. We can simply add each new layer after a '+' operator

```{r}
our_gss |>
  drop_na(sex) |>
  ggplot(
    aes(x = sex)) +
      geom_bar()
  
```

Voila! There's a pretty decent barplot. There are other kinds of statistical summaries we can take advantage of in ggplot, but the default behavior of `geom_bar()` will calculate the summary counts of the values of the x variable. 

Now we tweak a couple things to make things a bit nicer and illustrate some of the perks of ggplot's customizability.

Let's add a little color. We can indicate this back up at the `aes()` layer. This works by adding a fill aesthetic, and then we specify a variable. What we do there is tell R that we want the fill-color of the bars to vary on the basis of that variable. So, each bar will be filled with a different color for each response category of `sex` in our case. 

```{r}
our_gss |>
  drop_na(sex) |>
  ggplot(
    aes(x = sex, fill = sex)) +
      geom_bar()
```
Neat! This looks much better, and we'll play around with this more later, but now let's see how to add some axis & legend labels along with a title. The legend label actually works out fine as it is with `sex`, but the shorthand variable names often do not translate well as legend titles (imagine if it were 'realrinc', for example). So, I'll show you how to customize it just in case.

For the axis labels and title, we can add the `labs` layer
```{r}
our_gss |>
  drop_na(sex) |>
  ggplot(
    aes(x = sex, fill = sex)) +
      geom_bar() +
  labs(
    title = "Sex distribution of 2022 GSS Respondents",
    x = "Sex", 
    y = "Frequency") 

```

Then we can add the `guides` layer to customize the legend title for the `fill` aesthetic. 
```{r}
our_gss |>
  drop_na(sex) |>
  ggplot(
    aes(x = sex, fill = sex)) +
  geom_bar() +
  labs(
    title = "Sex distribution of 2022 GSS Respondents",
    x = "Sex", 
    y = "Frequency") +
  guides(fill = guide_legend(title="Respondent's sex"))

```
Lastly on this point, I'll also show you how to get rid of the legend entirely. You'll often want to customize the legend in the fashion I laid out above, but we actually don't really need it in this case. It's redundant with the x-axis labels. So, you can always get rid of a legend by adding the `guides()` layer and simply setting `fill` to 'none'.
```{r}
our_gss |>
  drop_na(sex) |>
  ggplot(
    aes(x = sex, fill = sex)) +
  geom_bar() +
  labs(
    title = "Sex distribution of 2022 GSS Respondents",
    x = "Sex", 
    y = "Frequency") +
  guides(fill = "none")

```



### Bivariate Barplots
The `fill` aesthetic actually allows us to quite easily create a bivariate version of the barplot.

Let's consider our bivariate analysis from a previous session: `cappun` and `dem_rep`.

If you need to recreate `dem_rep` from `partyid`, go ahead and run the following code:
```{r}
our_gss <- our_gss |>
  mutate(
    partyid_recoded=fct_collapse(partyid, 
"Democrat" = c("strong democrat", "not very strong democrat"),
"Republican" = c("strong republican","not very strong republican"),
"Independent" = c("independent, close to democrat", "independent (neither, no response)", "independent, close to republican"),
"Other Party" = c("other party")
)) |>
  mutate(dem_rep = fct_recode(
    partyid_recoded, 
    NULL="Other Party", 
    NULL="Independent"))
```
As a reminder, here is the cross-tab for that conjoint distribution:
```{r, eval = TRUE, echo = FALSE}
our_gss |>
  drop_na(cappun, dem_rep) |>
  tabyl(
    var1 = cappun,
    var2 = dem_rep) |>
  adorn_totals(where = "row") |>
  adorn_percentages() |>
  adorn_pct_formatting() |>
  adorn_ns(position = "rear") |>
  adorn_title(
    placement = "top",
    row_name = "Death Penalty Attitude",
    col_name = "Political Party") |>
  knitr::kable()
```

Now, we'll use our same barplot code from above, but this time we will set our x variable to `cappun` and swap out  the `fill` aesthetic to `dem_rep`. This means we want the fill-color of the bars to vary on the basis of the categories in `dem_rep`. I'll also add `cappun` and `dem_rep` to `drop_na()` and update the labels & title.

```{r}
our_gss |>
  drop_na(sex, cappun, dem_rep) |>
  ggplot(
    aes(x = cappun, fill = dem_rep)) +
  geom_bar() +
  labs(
    title = "Death Penalty Attitudes by Sex and Political Party",
    x = "Death penalty attitude", 
    y = "Frequency") +
  guides(fill = guide_legend(title="Political party"))

```
Good stuff! This is a stacked barplot and is a common way to display multivariate categorical data. I personally find it a little easier to intrepret when the columns are side-by-side rather than stacked on top of each other, so I'll show you how to do that too. This just requires setting a `position` mapping within `geom_bar()`. We set the position to 'dodge', which might sound a little counter-intuitive, which is because it actually has a more general purpose. The idea is that you want overlapping objects to 'dodge' one another, which will cause them to appear side by side rather than on top of one another. So, by doing so, we will un-nest our stacked bar charts and have each bar appear adjacent to one another.
```{r}
our_gss |>
  drop_na(sex, cappun, dem_rep) |>
  ggplot(
    aes(x = cappun, fill = dem_rep)) +
  geom_bar(position = "dodge") +
  labs(
    title = "Death Penalty Attitudes by Political Party",
    x = "Death penalty attitude", 
    y = "Frequency") +
  guides(fill = guide_legend(title="Political party"))
```
Not too shabby. This is a great way to complement the presentation of a bivariate analysis, and it's also great for quickly getting a sense of the relationship among variables of interest.

## Tables
Now, let's learn a way to get some pretty snazzy frequency tables and cross-tabs using the `gtsummary` package, which is designed specifically for quickly producing publication-ready tables.

I'll load it in below. If you need to install it, you can run `install.packages("gtsummary")`

```{r}
library(gtsummary)
```

### Frequency tables
The function we'll get the most mileage out of here is called `tbl_summary()`. It really does an incredible amount of stuff right out of the box, but it also offers a great deal of customizability. I'll note that `gtsummary()` can be a little idiosyncratic compared to some of the functions we've learned about already, and you can really get into the weeds with it. But I'll try to focus us here on just the things from which we can really get a lot of value.

It takes a data frame as it's first input, so, like ggplot, it plays well with the pipe operator. 

We'll make a simple frequency table for univariate analysis of `cappun`. I'll first pass `cappun` through `drop_na()`, and then we'll pipe the output of that right into `tbl_summary()`. To get started, we just need to provide the variable we want to include, which has a straightforward enough input.

```{r}
our_gss |>
  drop_na(cappun) |>
  tbl_summary(
    include = cappun)
```
Excellent. This has some good detail right away. It automatically shows counts and percentages, and also gives the grand total while adding a footnote that this is what the percentages refer to. There are at least two things we'll want to customize.

For one, you might want to change 'Characteristic' to something like 'Variable.' We can do that like so:
```{r}
our_gss |>
  drop_na(cappun) |>
  tbl_summary(
    include = cappun) |>
  modify_header(label ~ "Variable")
```
Note the use of the tilde symbol `~` here. Without getting too into the weeds, this is one of the idiosyncratic things about `gtsummary` I alluded to above. For our purposes, just observe that we need to do that here and don't worry too much about it.

However, observe that 'Variable' replaces 'Characteristic', but it's no longer bold. Thankfully, `gtsummary` has some font formatting conventions for us to take advantage of. If we simply place the quoted text between two asterisk (*), the text will be bolded

```{r}
our_gss |>
  drop_na(cappun) |>
  tbl_summary(
    include = cappun) |>
  modify_header(label ~ "**Variable**")
```
Good. Now we'll want a better variable label than 'cappun'. Let's change that up.
```{r}
our_gss |>
  drop_na(cappun) |>
  tbl_summary(
    include = cappun,
    label = list(
      cappun = "Death Penalty Attitude")) |>
  modify_header(label ~ "**Variable**")
```
Within the `tbl_summary()` function, we just need to add a 'label' input. Then you can specify your variable name and give a character vector for the label that we want. Because the 'label' input is designed to label multiple variables at once, it expects that you will give it a list of things. So, even if you're only working with one variable, you will need to put the label inside of `list()`.

### Contingency tables
We can also make a quick and easy contingency table for bivariate analysis. Let's re-create our `cappun` x `dem_rep` table.

Always remember to give your independent variable to the `by =` input, and you dependent variables to the `include =` input.

```{r}
our_gss |>
  drop_na(cappun, dem_rep) |>
  tbl_summary(
    by = dem_rep,
    include = cappun,
    label = list(
      cappun = "Death Penalty Attitude")) |>
  modify_header(label ~ "**Variable**")
```
Notice that, for a contingency table, we give our dependent variable with the `by =` input, and then we include our independent variable with the `include =` we saw above. I've changed the 'Characteristic' label like we did before, and I've changed the label argument to reflect the label for `dem_rep`.

One last thing we can do is add a spanning head for `dem_rep`. 

```{r}
our_gss |>
  drop_na(cappun, dem_rep) |>
  tbl_summary(
    by = dem_rep,
    include = cappun,
    label = list(
      cappun = "Death Penalty Attitude")) |>
  modify_header(label ~ "**Variable**") |>
  modify_spanning_header(all_stat_cols() ~ "**Political Party**") 
```
We use the `modify_spanning_head()` function for this. Within that function, we can use `all_stat_cols()`, which will let the function know that we want the label for this header to span across all of our table columns. Then, I use the same formatting with the tilde and bolding that we saw in `modify_header()`.


### Chi-squared test
Now, a really neat feature of `tbl_summary()` is that it will automatically detect the type of variables that we have, and it will perform an appropriate statistical test. There's a lot of customization that you can do here, but this will work great out of the box for us.

All we have to do is pipe the command we just produced into `add_p()`, which will automatically calculate a p-value using a relevant statistical test.
```{r}
our_gss |>
  drop_na(cappun, dem_rep) |>
  tbl_summary(
    by = dem_rep,
    include = cappun,
    label = list(
      cappun = "Death Penalty Attitude")) |>
  modify_header(label ~ "**Variable**") |>
  modify_spanning_header(all_stat_cols() ~ "**Political Party**") |>
  add_p()
```
Very neat! This automatically recognized that we have categorical variables, ran a chi-squared test, and reported the p-value. Note that it doesn't give the actual chi-squared value by default, but that information is in there. We can manually add a column like so:
```{r}
our_gss |>
  drop_na(cappun, dem_rep) |>
  tbl_summary(
    by = dem_rep,
    include = cappun,
    label = list(
      cappun = "Death Penalty Attitude")) |>
  modify_header(label ~ "**Variable**") |>
  modify_spanning_header(all_stat_cols() ~ "**Political Party**") |>
  add_p() |>
  modify_header(statistic ~ "**Chi-square value**")
```
Good stuff. Lots of great detail here, so this is pretty much good to go.

### Elaboration Model
Lastly, this also gives us an easy way to automatically produce a 3-way cross-tab for multivariate analysis. We'll need to change a couple of things around, but this can be done without too much work in `gtsummary`.

In our set up here, we have `cappun` as our dependent variable and `dem_rep` as our independent variable. Let's add `sex` as a test variable, and see whether sex has any effect on the relationship we have observed between death penalty attitudes and political party.

For this, we need the `tbl_strata()` function.

```{r}
our_gss |>
  select(cappun, sex, dem_rep) |>
  drop_na(cappun, sex, dem_rep) |>
  tbl_strata(
    strata = sex,
    .tbl_fun = 
      ~ .x |>
      tbl_summary(
        by = dem_rep, 
        include = cappun,
        label = list(
          cappun = "Death Penalty Attitude"
        )) |>
      modify_header(label ~ "**Variable**") |>
      add_n() |>
      add_p()
      
  )
```
Now, as an exercise, let's think about what we have here. 

We have our original relationship predicting death-penalty attitudes based on political affiliation. But now we can see this relationship for both men and women. The female group has 941 respondents and the male group has 804.

If we look at the percentages for both the male & female groups, they are really quite similar. It seems like the relationship is basically the same. Not only this, but we can see that a chi-squared test has been run for both the male and female subgroups. Both of these tests returned statistically significant p-values, as we can see in the table. 

So, this would be a case of replication. We have replication when our zero-order relationship remains statistically significant after introducing our test variable. In this case, we observed a statistically significant relationship between political affiliation and death-penalty attitudes. After we added `sex` as a test variable, this original relationship remained statistically significant across the two response categories of `sex`. If the percentages were markedly different across males and females, we could say that this was specification, as that would suggest that---even if political affiliation is predictive of death penalty attitudes---the relationship is different for men and women. 