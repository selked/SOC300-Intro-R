create_var(dino_mean)
create_var<-function(x) {
x$new_var <- rep(NA, 13)
row_num <- row.names(x$new_var)
for (i in x$new_var) {
x$new_var[row.names(i)]<-paste0("data_set", rownames(i))
}
}
create_var(dino_mean)
View(dino_mean)
row.names(dino_mean)
create_var<-function(x) {
new_var <- rep(NA, 13)
row_num <- row.names(x$new_var)
for (i in x$new_var) {
new_var[row.names(i)]<-paste0("data_set", rownames(i))
x <- cbind(x,new_var)
}
}
create_var(dino_mean)
create_var<-function(x) {
new_var <- NULL
row_num <- row.names(x$new_var)
for (i in x$new_var) {
new_var[row.names(i)]<-paste0("data_set", rownames(i))
x <- cbind(x,new_var)
}
}
create_var(dino_mean)
create_var<-function(x) {
new_var <- NULL
row_num <- row.names(x$new_var)
for (i in new_var) {
new_var[row.names(i)]<-paste0("data_set", rownames(i))
x <- cbind(x,new_var)
}
}
create_var(dino_mean)
create_var<-function(x) {
new_var <- NULL
for (i in new_var) {
new_var[row.names(i)]<-paste0("data_set", rownames(i))
}
x<-cbind(x,new_var)
}
create_var(dino_mean)
create_var<-function(x) {
new_var <- NULL
for (i in length(x)) {
new_var[i]<-paste0("data_set", rownames(i))
}
x<-cbind(x,new_var)
}
create_var(dino_mean)
create_var<-function(x) {
new_var <- NULL
for (i in nrow(x)) {
new_var[i]<-paste0("data_set", rownames(i))
}
x<-cbind(x,new_var)
}
create_var<-function(x) {
new_var <- NULL
for (i in nrow(x)) {
new_var[i]<-paste0("data_set", rownames(i))
}
x<-cbind(x,new_var)
}
create_var(dino_mean)
create_var<-function(x) {
new_var <- vector(mode="character", length=nrow(x))
for (i in new_var) {
new_var[rownames(new_var)]<-paste0("data_set", rownames(new_var))
}
x<-cbind(x,new_var)
}
create_var(dino_mean)
nrow(dino_mean)
create_var<-function(x) {
new_var <- vector(mode="character", length=nrow(x))
x<-cbind(x,new_var)
for (i in x$new_var) {
x$new_var <- append(new_var, c("dataset_", rownames(x)))
}
}
create_var(dino_mean)
dino_mean$new_var<-vector(mode="character", length=nrow(dino_mean))
View(dino_mean)
create_var<-function(x) {
x$new_var <- vector(mode="character", length=nrow(x))
for (i in x$new_var) {
x$new_var <- append(xnew_var, c("dataset_", rownames(x)))
}
}
create_var(dino_mean)
create_var<-function(x) {
x$new_var <- vector(mode="character", length=nrow(x))
for (i in x$new_var) {
x$new_var <- append(x$new_var, c("dataset_", rownames(x)))
}
}
create_var(dino_mean)
create_var<-function(x) {
x$new_var <- vector(mode="character", length=nrow(x))
for (i in x$new_var) {
x$new_var <- append(x$new_var, c("dataset_", 1:nrow(x), after="_"))
}
}
create_var(dino_mean)
create_var<-function(x) {
x$new_var <- vector(mode="character", length=nrow(x))
for (i in x$new_var) {
paste("dataset_")
}
}
create_var(dino_mean)
View(dino_mean)
dino_mean<-dino_mean[,-7]
create_var<-function(x) {
x$new_var <- vector(mode="character", length=nrow(x))
for (i in x$new_var) {
paste("dataset_")
}
}
create_var(dino_mean)
create_var<-function(x) {
new_var <- vector(mode="character", length=nrow(x))
for (i in new_var) {
paste("dataset_")
}
cbind(x,new_var)
}
create_var(dino_mean)
create_var<-function(x) {
new_var <- vector(mode="character", length=nrow(x))
for (var in new_var) {
append(var, paste("dataset_", var[[i]]))
}
cbind(x,new_var)
}
create_var(dino_mean)
create_var<-function(x) {
new_var <- vector(mode="character", length=nrow(x))
for (var in new_var) {
append(var, paste("dataset_", var[[]]))
}
cbind(x,new_var)
}
create_var(dino_mean)
create_var<-function(x) {
new_var <- vector(mode="character", length=nrow(x))
for (var in new_var) {
append(var, paste("dataset_"))
}
cbind(x,new_var)
}
create_var(dino_mean)
View(dino_mean)
create_var<-function(x) {
new_var <- vector(mode="character", length=nrow(x))
for (var in new_var) {
append(var, paste("dataset_"))
}
x<-cbind(x,new_var)
}
create_var(dino_mean)
View(dino_mean)
create_var<-function(x) {
new_var <- vector(mode="character", length=nrow(x))
for (var in new_var) {
append(var, "dataset_")
}
x<-cbind(x,new_var)
}
create_var(dino_mean)
dino_mean <- dino |>
group_by(dataset) |>
summarise("mean_x" = mean(x),
"mean_y" = mean(y),
"std_x" = sd(x),
"std_y" = sd(y),
) |>
mutate_if(is.numeric, round, 1)
View(dino_mean)
dino_mean <- dino |>
group_by(dataset) |>
summarise("mean_x" = mean(x),
"mean_y" = mean(y),
"std_x" = sd(x),
"std_y" = sd(y),
) |>
mutate_if(is.numeric, round, 1) |>
select(!dataset)
View(dino_mean)
dino |> # filter (dataset %in% c("bullseye", "star", "dino", "dots")) |>
ggplot(
aes(x=x, y=y, color=dataset)) +
geom_point()+
theme(legend.position = "none") +
facet_wrap(~dataset, nrow=3)
dino |> # filter (dataset %in% c("bullseye", "star", "dino", "dots")) |>
ggplot(
aes(x=x, y=y, color=dataset)) +
geom_point()+
geom_line(stat="lm")
dino |> # filter (dataset %in% c("bullseye", "star", "dino", "dots")) |>
ggplot(
aes(x=x, y=y, color=dataset)) +
geom_point()+
geom_line()+
theme(legend.position = "none") +
facet_wrap(~dataset, nrow=3)
dino |> # filter (dataset %in% c("bullseye", "star", "dino", "dots")) |>
ggplot(
aes(x=x, y=y, color=dataset)) +
geom_point()+
geom_line(method="lm")+
theme(legend.position = "none") +
facet_wrap(~dataset, nrow=3)
dino |> # filter (dataset %in% c("bullseye", "star", "dino", "dots")) |>
ggplot(
aes(x=x, y=y, color=dataset)) +
geom_point()+
geom_abline()+
theme(legend.position = "none") +
facet_wrap(~dataset, nrow=3)
theme(legend.position = "none") +
facet_wrap(~dataset, nrow=3)
dino |> # filter (dataset %in% c("bullseye", "star", "dino", "dots")) |>
ggplot(
aes(x=x, y=y, color=dataset)) +
geom_smooth(method="lm")+
theme(legend.position = "none") +
facet_wrap(~dataset, nrow=3)
dino |> # filter (dataset %in% c("bullseye", "star", "dino", "dots")) |>
ggplot(
aes(x=x, y=y, color=dataset)) +
geom_smooth(method="lm")+
geom_point()+
theme(legend.position = "none") +
facet_wrap(~dataset, nrow=3)
dino |> # filter (dataset %in% c("bullseye", "star", "dino", "dots")) |>
ggplot(
aes(x=x, y=y, color=dataset)) +
geom_smooth(method="lm")+
ylim(0,100)+
theme(legend.position = "none") +
facet_wrap(~dataset, nrow=3)
dino |> # filter (dataset %in% c("bullseye", "star", "dino", "dots")) |>
ggplot(
aes(x=x, y=y, color=dataset)) +
geom_smooth(method="lm")+
ylim(0,100)+
geom_point()+
theme(legend.position = "none") +
facet_wrap(~dataset, nrow=3)
View(dino_mean)
View(dino_mean)
View(dino_mean)
View(dino_mean)
5+2
our_object <- 5+2
our_object
our_object + 3
our_object * 100
numeric_vec <- c(1.2, 3.4, 5.6, 7.1, 2.8)
integer_vec <- c(2L,1L,3L,1L,4L) # placing an 'L' after a number is the way to let R know you want it to be treated as an integer rather than a real number
logical_vec <- c(TRUE, FALSE, TRUE, FALSE, FALSE) #upper-case 'true' and 'false' have fixed values in R and, when used without quotes, will refer to these pre-defined logical values
character_vec <- c("east", "west", "south", "south", "north") #in R, you place character strings in quotation marks--otherwise, R will assume you are trying to call an object and you'll likely get an error
#Take the mean() function, for example. As the name implies, this function will return the arithmetic mean of a numeric vector. Let's give it the one we just made above:
mean(numeric_vec)
#Note that it gives the same response as if we had manually calculated it. Functions can make our lives a lot easier with larger amounts of data, but always make sure you're familiar with what's going on under the hood of any given function.
(1.2+3.4+5.6+7.1+2.8)/5
#But, what happens when we run the following command?
mean(character_vec)
#It doesn't make any sense to take the mean of the cardinal directions, so it will throw a warning message. We need a variable that can be represented numerically. Note that mean() also accepts logical variables, as, in R, TRUEs will be counted as 1s and FALSEs will be counted as 0s. In this case, you will be getting the proportion of true responses
mean(logical_vec)
(1+0+1+0+0)/5
p_id_vec<-c("p1", "p2", "p3", "p4", "p5")
our_df<-data.frame(
p_id = p_id_vec, # a participant ID variable for each dog owner
num_dogs = integer_vec, # a variable for the number of dogs each participant has
side_of_town = character_vec, # the side of town each participant lives in
food_per_day = numeric_vec, # daily dog food amount in ounces
has_a_labrador = logical_vec # a variable indicating whether a participant has a lab or not
)
#Take a look at our new data frame by clicking on the object in our Environment window at the upper right, or by running the following command. Both do the same thing
View(our_df)
#Once we have created a data frame, we can refer to individual variables with the $ operator in R
our_df$food_per_day
mean(our_df$food_per_day)
#This will give us the value in the cell of the 3rd row, in the 2nd column. In other words, this will target the 3rd participant (3rd row) and tell us the number of dogs they own (2nd variable column).
our_df[3,2]
#2nd row, all columns
our_df[2,]
#3rd column, all rows
our_df[,3]
#We can look at some basic characteristics of the data frame with the summary() function. Note that it will return different information depending on the data type of the variable
summary(our_df)
our_df$num_dogs <- factor(
our_df$num_dogs, # the first input is the vector we are turning into a factor
levels=c("1", "2", "3", "4"), # then we indicate the levels in the order that makes sense
ordered = TRUE # and lastly we turn on a process that tells R that this order is important
)
our_df$num_dogs <- factor(our_df$num_dogs, levels=c("1", "2", "3", "4"), ordered = TRUE)
#Take a look back at the summary. Now, instead of 5 separate character strings, we can see the breakdown of how many people own a certain number of dogs.
summary(our_df)
#We can also confirm that our ordinal variable is appropriately ordered using the levels() function. Compare the output of the following two commands
our_df$side_of_town
our_df$num_dogs
#Note that the str() command is also useful for quickly gleaning the various types of a new data frame's variables. It will show us our variable names, the data types, and then a preview of the first several values in each variable column.
str(our_df)
#We can turn this variable into a factor variable with base R's as.factor() function.
our_df$side_of_town <- as.factor(our_df$side_of_town)
#Take a look back at the summary. Now, instead of 5 separate character strings, we can see the breakdown of how many people own a certain number of dogs.
summary(our_df)
#We can also confirm that our ordinal variable is appropriately ordered using the levels() function. Compare the output of the following two commands
our_df$side_of_town
our_df$num_dogs
#Note that the str() command is also useful for quickly gleaning the various types of a new data frame's variables. It will show us our variable names, the data types, and then a preview of the first several values in each variable column.
str(our_df)
load(file.choose())
View(gss_sub)
#Take a look at our data frame.
View(gss_sub)
gss_inc <- gss_sub |>
group_by(sex, race) |>
summarize(
"mean_minc" = mean(realrinc)
)
gss_inc <- gss_sub |>
group_by(sex) |>
summarize(
"mean_inc" = mean(realrinc)
)
str(gss_sub)
gss_sub$realrinc<-as.numeric(gss_sub$realrinc)
gss_inc <- gss_sub |>
group_by(sex) |>
summarize(
"mean_inc" = mean(realrinc)
)
View(gss_inc)
summarize(
"mean_inc" = mean(realrinc)
)
gss_inc <- gss_sub |>
group_by(sex) |>
drop_na(realrinc) |>
summarize(
"mean_inc" = mean(realrinc)
)
View(gss_inc)
View(gss_sub)
load(file.choose())
View(gss_sub)
install.packages("nbastatR")
install.packages("hoopR")
library(hoopR)
devtools::install_github("abresler/nbastatR")
devtools::install_github("abresler/nbastatR")
library(nbastatR)
warnings()
get_teams_seasons_shots(teams = "Cleveland Cavaliers",
season_types = "Playoffs",
seasons = 2018,
measures = "FGA",
return_message = T)
library(nbastatR)
get_teams_seasons_shots(teams = "Cleveland Cavaliers",
season_types = "Playoffs",
seasons = 2018,
measures = "FGA",
return_message = T)
?nbastatR
remove.packages("nbastatR")
library(hoopR)
interval_ratio_vec <- c(1.2, 3.4, 5.6, 7.1, 2.8)
ordinal_vec <- c("1-2", "3-4", "5 or more") #When you want R to treat something as a character string (rather than as a command or an object of some kind), you place it in quotations.
nominal_vec <- c("east", "west", "south", "south", "north")
typeof(interval_ratio_vec) # the typeof() function can be used to check what data-type a given object is
logical_vec <- c(TRUE, FALSE, TRUE, FALSE, FALSE) #upper-case 'true' and 'false' have fixed values in R and, when used without quotes, will refer to these pre-defined logical values
#Note that it gives the same response as if we had manually calculated it. Functions can make our lives a lot easier with larger amounts of data, but always make sure you're familiar with what's going on under the hood of any given function.
(1.2+3.4+5.6+7.1+2.8)/5
p_id_vec<-c("p1", "p2", "p3", "p4", "p5")
our_df<-data.frame(
p_id = p_id_vec, # a participant ID variable for each dog owner
num_dogs = ordinal_vec, # a variable for the number of dogs each participant has
side_of_town = nominal_vec, # the side of town each participant lives in
food_per_day = interval_ratio_vec, # daily dog food amount in ounces
has_a_labrador = logical_vec # a variable indicating whether a participant has a lab or not
)
ordinal_vec <- c("1-2", "5 or more", "1-2", "3-4", "5 or more") #When you want R to treat something as a character string (rather than as a command or an object of some kind), you place it in quotations.
our_df<-data.frame(
p_id = p_id_vec, # a participant ID variable for each dog owner
num_dogs = ordinal_vec, # a variable for the number of dogs each participant has
side_of_town = nominal_vec, # the side of town each participant lives in
food_per_day = interval_ratio_vec, # daily dog food amount in ounces
has_a_labrador = logical_vec # a variable indicating whether a participant has a lab or not
)
#Take a look at our new data frame by clicking on the object in our Environment window at the upper right, or by running the following command. Both do the same thing
View(our_df)
#Once we have created a data frame, we can refer to individual variables with the $ operator in R
our_df$food_per_day
mean(our_df$food_per_day)
#This will give us the value in the cell of the 3rd row, in the 2nd column. In other words, this will target the 3rd participant (3rd row) and tell us the number of dogs they own (2nd variable column).
our_df[3,2]
#Take the 2nd row but keep all columns
our_df[2,]
#Take the 3rd column but keep all rows
our_df[,3]
#To tie it together, note that the following two commands do exactly the same thing. With R, there are often a number of different ways to accomplish the same task, and learning to recognize these symmetries will help you become fluent in R over the long haul.
mean(our_df$food_per_day)
mean(our_df[,4])
#We can look at some basic characteristics of the data frame with the summary() function. Note that it will return different information depending on the data type of the variable
summary(our_df)
#We can turn this variable into a factor variable with base R's as.factor() function.
our_df$side_of_town <- as.factor(our_df$side_of_town)
#Check the summary() output again and notice how the output is reported now
summary(our_df)
our_df$num_dogs <- factor(
our_df$num_dogs, # the first input is the vector we are turning into a factor
levels=c("1", "2", "3", "4"), # then we indicate the levels in the order that makes sense
ordered = TRUE # and lastly we turn on a process that tells R that this order is important
)
our_df$num_dogs <- factor(our_df$num_dogs, levels=c("1", "2", "3", "4"), ordered = TRUE)
#Take a look back at the summary. Now, instead of 5 separate character strings, we can see the breakdown of how many people own a certain number of dogs.
summary(our_df)
our_df<-data.frame(
p_id = p_id_vec, # a participant ID variable for each dog owner
num_dogs = ordinal_vec, # a variable for the number of dogs each participant has
side_of_town = nominal_vec, # the side of town each participant lives in
food_per_day = interval_ratio_vec, # daily dog food amount in ounces
has_a_labrador = logical_vec # a variable indicating whether a participant has a lab or not
)
#We can turn this variable into a factor variable with base R's as.factor() function.
our_df$side_of_town <- as.factor(our_df$side_of_town)
our_df$num_dogs <- factor(
our_df$num_dogs, # the first input is the vector we are turning into a factor
levels=c("1-2", "3-4", "5 or more"), # then we indicate the levels in the order that makes sense
ordered = TRUE # and lastly we turn on a process that tells R that this order is important
)
#Take a look back at the summary. Now, instead of 5 separate character strings, we can see the breakdown of how many people own a certain number of dogs.
summary(our_df)
#Take a look back at the summary. Now, instead of 5 separate character strings, we can see the breakdown of how many people own a certain number of dogs.
summary(our_df)
#We can also verify that the levels are ordered by applying the summary() function to the variable column
summary(our_df$num_dogs)
levels(our_df$num_dogs)
str(our_df)
#Note that the str() command is also useful for quickly gleaning the various data types of variable columns within a data frame. It will show us our variable names, the data types, and then a preview of the first several values in each variable column.
str(our_df)
load(file.choose())
View(gss_sub)
str(gss_sub)
gss_sub$realrinc_r <- as.factor(gss_sub$realrinc)
View(gss_sub)
str(gss_sub)
gss_sub$realrinc_r <- as.numeric(gss_sub$realrinc)
str(gss_sub)
gss_sub$realrinc_r <- as.numeric(as.character(gss_sub$realrinc))
str(gss_sub)
gss_sub$realrinc_r2 <- gss_sub$realrinc |>
as.character() |>
as.numeric()
print(gss_sub)
print(as_tibble(gss_sub))
library(tidyverse)
print(gss_sub)
str(gss_sub)
class(gss_sub[,])
class(gss_sub[,colnames(gss_sub)])
summary(gss_sub)
tbl_sum(gss_sub)
tbl_sum(haven::as_factor(gss_sub))
setwd("C:/Users/selke/Documents/git_repos/SOC300-Intro-R")
#install.packages("text2map")
#install.packages("gutenbergr")
library(ggrepel)
library(text2map)
library(text2vec)
library(gutenbergr)
library(tidyverse)
library(textclean)
library(stringi)
library(text2map.pretrained)
library(flextable)
library(huxtable)
#Load the data you just downloaded (do this once per session)
data("vecs_fasttext300_wiki_news")
#Download FastText Wiki News dataset (Only do this once)
download_pretrained("vecs_fasttext300_wiki_news")
#Load the data you just downloaded (do this once per session)
data("vecs_fasttext300_wiki_news")
#Rename object for easier manipulation later
my_wv<-vecs_fasttext300_wiki_news
rm(vecs_fasttext300_wiki_news)
View(my_wv)
#Build DTM that excludes stop words (code from Stoltz & Taylor)
dtm_ja <- workingjobs.df |>
dtm_builder(string_lemma, doc_id) |>
dtm_stopper(stop_list = get_stoplist("snowball2014"),
stop_docprop = c(.01, Inf))
load(C:/Users/selke/Desktop/Scholarship/USAJobs Project/ja_reprocessed.rda)
load("C:/Users/selke/Desktop/Scholarship/USAJobs Project/ja_reprocessed.rda")
#Build DTM that excludes stop words (code from Stoltz & Taylor)
dtm_ja <- workingjobs.df |>
dtm_builder(string_lemma, doc_id) |>
dtm_stopper(stop_list = get_stoplist("snowball2014"),
stop_docprop = c(.01, Inf))
#Stop words removed
ja_vectors <- my_wv[rownames(my_wv) %in% colnames(dtm_ja), ]
