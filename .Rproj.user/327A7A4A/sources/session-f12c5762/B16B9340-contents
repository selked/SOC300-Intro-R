setwd("C:/Users/selke/Desktop/Teaching/SOC 300 F 2025")

##We will make extensive use of Kieran Healy's 'gssr' and 'gssrdoc' packages. There are a couple different ways to import GSS data for R, but this is probably the most convenient. You can read more about the packages here: https://kjhealy.github.io/gssr/articles/overview.html, and I also take inspiration from several of Healy's coding vignettes detailed there.

#install.packages('gssr', repos = c('https://kjhealy.r-universe.dev', 'https://cloud.r-project.org'))

#install.packages('gssrdoc', repos = c('https://kjhealy.r-universe.dev', 'https://cloud.r-project.org'))

#install.packages("srvyr")

library(gssr)
library(gssrdoc)
library(survey)
library(srvyr)
library(dplyr)
library(forcats)
library(ggplot2)

#Load in the cumulative data set -- it's pretty big, so it'll probably take a second
data(gss_all)

#Note that if you know you only want a certain year, the gssr package offers a helpful function for retrieving a single year
gss_2018<-gss_get_yr(2018)

#We can also retrieve a single year by taking a subset of the cumulative file
gss_2024<-subset(gss_all, year==2024)

#Note, however, that there are still nearly 7000 variable columns in this data frame. That number reflects the variable total across 1974-2024--individual years generally have far fewer variables. 

#It's not strictly necessary, but we can clean this subset up by removing any columns that exclusively contain 'NA' values (not available). These are likely column reflecting questions that were not asked in 2024. In any case, a question that has no responses at all isn't useful for us either.


#The following code specifies a function that targets columns where there is at least one value that is not NA
not_all_na <- function(x) any(!is.na(x))

#And then this code uses that function to specify that we want a new data frame where we retain only these columns that are not exclusively NAs
gss_chk<- gss_2024 %>%
  select(where(not_all_na))

#Note for myself: Columns don't perfectly match up between this manually subset object and the single-year download from NORC. Here's some code to check which ones aren't matching.
uneeded<-which(!colnames(gss_check) %in% colnames(gss_chk))

#Go ahead and a take a quick look at the actual GSS data. You can do so by clicking on the object in the Environment window, or by running the following command
View(gss_all)

#Because we also installed the gssrdoc package, our R help functions are now integrated with the GSS variable codebook. This means that we can quickly retrieve more detailed information on variables in our data frame using the '?' operator in R
?wrkstat

#Subset the data so that we can focus on a just a few variables of interest
cont_vars <- c("year", "id", "ballot", "age")

cat_vars <- c("race", "sex", "marsame1", "partyid")

wt_vars <- c("vpsu",
             "vstrat",
             "oversamp",
             "formwt",              # weight to deal with experimental randomization
             "wtssps",              # weight variable
             "sampcode",            # sampling error code
             "sample")              # sampling frame and method

my_vars <- c(cont_vars, cat_vars, wt_vars)

gss_mar <- gss_all |>
  select(all_of(my_vars))

# Recode some of the data

#Make sure all missing data is coded as NA
gss_mar <- gss_mar |>
  mutate(across(everything(), haven::zap_missing))

#Take a look at the file now. Notice that our 
View(gss_mar)



#Recode categorical variables into factors
gss_mar <- gss_mar |>
  mutate(across(all_of(cat_vars), forcats::as_factor))         

#Make sure weight variables are numeric
gss_mar <- gss_mar |>
  mutate(across(all_of(wt_vars), as.numeric))

#Create a variable that will allow us to drop levels from 'year' column where there's no response data for our questions
gss_mar <- gss_mar |>
  mutate(year_m=droplevels(factor(year)))


#The following code will create a new 'sample' variable that excludes a couple of survey procedures involving oversampling certain populations. These can be great for certain analyses, but less so for generalizing to the US population
gss_mar <- gss_mar |>
  mutate(samplerc = case_when(sample %in% c(3:4) ~ 3, 
                     sample %in% c(6:7) ~ 6,
                     .default = sample))

#Let's binarize our 'marsame1' variable. First, let's double check the content of the variable
levels(gss_mar$marsame1)

#That command will gives us the factor levels, but note that there's also a value '6' corresponding to the NAs--verify that with the following command
gss_mar |> count(marsame1)

#We want to create a variable that just represents agreement and disagreement, so we'll combine values 1&2, discard value 3, and then combine values 4&5. 
gss_mar <- gss_mar |>
  mutate(marsame1_b=fct_collapse(gss_mar$marsame1, "Agree"=c("strongly agree", "agree"), "Disagree"=c("strongly disagree", "disagree")))

#Collapse the political party variables into just "Democrat," "Republican," and "Independent"
gss_mar <- gss_mar |>
  mutate(party_id_b=fct_collapse(gss_mar$partyid, "Democrat"=c("strong democrat", "not very strong democrat"), "Republican"=c("strong republican", "not very strong republican"), "Independent"=c("independent, close to democrat", "independent (neither, no response)", "independent, close to republican")))

#We can use this to get rid of independents and 'other party' from our analysis
gss_mar$party_id_b<- gss_mar$party_id_b |>
  fct_recode(NULL="other party", NULL="Independent")

#Similarly, we can exclude the 'other' category in the race variable to focus on differences across white/black
gss_mar$race_b <- gss_mar$race |>
  fct_recode(NULL="other")

#Check and make sure our recoding worked
gss_mar |> count(marsame1_b)  
gss_mar |> count(party_id_b)
gss_mar |> count(race_b)

#Some behind-the-scenes settings for the survey statistics
options(survey.lonely.psu = "adjust")
options(na.action="na.pass")  
  
gss_svy <- gss_mar |>
  filter(year > 1972) |>
  tidyr::drop_na(marsame1_b, sex, party_id_b, race_b) |>
  mutate(stratvar = interaction(year, vstrat)) |>
  as_survey_design(id = vpsu,
                   strata = stratvar,
                   weights = wtssps,
                   nest = TRUE)

out_mar <- gss_svy |>
  group_by(year, sex, party_id_b, marsame1_b) |>
  summarize(prop = survey_mean(na.rm = TRUE, vartype = "ci")) |> 
  drop_na(sex)

out_mar_race <- gss_svy |>
  group_by(year, sex, party_id_b, marsame1_b, race_b) |>
  summarize(prop = survey_mean(na.rm = TRUE, vartype = "ci")) |> 
  drop_na(sex) |>
  drop_na(race_b)

theme_set(theme_minimal())

g<- guide_legend("Political Party")

sex_labs <- c(
  "male" = "Male",
  "female" = "Female"
)

race_labs <- c(
  "white" = "White",
  "black" = "Black",
  "other" = "Other"
)


out_mar |> 
  filter(marsame1_b == "Disagree") |>
  ggplot(mapping = 
           aes(x = year, y = prop,
               ymin = prop_low, 
               ymax = prop_upp,
               color = party_id_b, 
               group = party_id_b, 
               fill = party_id_b)) +
  geom_line(linewidth = 1.2) +
  geom_ribbon(alpha = 0.3, color = NA) +
  scale_x_continuous(breaks = seq(2006, 2018, 2)) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  scale_color_manual(values=c("Democrat"="blue", "Republican"="red"))+
  scale_fill_manual(values=c("Democrat"="blue", "Republican"="red"))+
  guides(color=g, group=g, fill=g)+
  coord_cartesian(xlim=c(2005,2019))+
  labs(x = "Year", 
       y = "Percent Disagreeing",
       title = "Percent Diagreement with Gay Marriage Rights",
       caption="\nData source: General Social Survey")+
  facet_wrap(~sex, labeller=as_labeller(sex_labs)) +
  theme_minimal()+
  theme(legend.position = "bottom")

out_mar_race |> 
  filter(marsame1_b == "Disagree") |>
  ggplot(mapping = 
           aes(x = year, y = prop,
               ymin = prop_low, 
               ymax = prop_upp,
               color = race_b, 
               group = race_b, 
               fill = race_b)) +
  geom_line(linewidth = 1.2) +
  geom_ribbon(alpha = 0.3, color = NA) +
  scale_x_continuous(breaks = seq(2006, 2018, 2)) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  guides(color=g, group=g, fill=g)+
  coord_cartesian(xlim=c(2005,2019))+
  labs(x = "Year", 
       y = "Percent Disagreeing",
       title = "Percent Diagreement with Gay Marriage Rights",
       caption="\nData source: General Social Survey")+
  facet_grid(~party_id_b)




#Datasaurus Dozen 

dino_mean <- dino |>
  group_by(dataset) |> 
        summarise("mean_x" = mean(x), 
                  "mean_y" = mean(y),
                  "std_x" = sd(x),
                  "std_y" = sd(y),
                                      ) |>
  mutate_if(is.numeric, round, 1) |>
  select(!dataset)
        

dino |> # filter (dataset %in% c("bullseye", "star", "dino", "dots")) |>
  ggplot(
  aes(x=x, y=y, color=dataset)) +
    geom_smooth(method="lm")+
    ylim(0,100)+
    geom_point()+
    theme(legend.position = "none") +
    facet_wrap(~dataset, nrow=3)


