#R is a very widely used programming language designed specifically for statistical data science. In order to make our lives easier, we pair R with R Studio, which is what's known as an Integrated Development Environment (IDE). Using R on its own would likely prove a sort of enigmatic and frustrating process, particularly for those of us without much programming experience. An IDE creates a user-friendly interface for R that allows us to easily view and manipulate the objects we use it to create.

#Up here, we are typing away in a new script file. Commands can be run by typing them directly in the console below, but we typically want to save and retrieve our commands for later, and script files allow us to do that. Anything you type in the console will be lost after you close out your session.

#You will notice that I am including a hash mark (#) before each line of text so far. In R, the # symbol indicates that the computer should treat any text that follows as a comment and not as a command to be processed by R. You should get in the habit of leaving comments on your scripts. It's especially helpful in the event that you use R for a project you collaborate on with others, and you will likely find comments helpful for your own scripts when you revisit them after a while away. 



#First, we will start by exploring some of the basic characteristics of R.

#R can be used as a simple calculator and will process both numbers and conventional mathematical operator symbols. You can run the commands below by placing your cursor at the beginning or end of the line and pressing CTRL+Enter (Windows) or Command+Return (Mac)

5+2

#You should see the result displayed in the console below.

#R is especially helpful for allowing us to create and store objects that we can call and manipulate later. We can create names for these objects and then use R's 'assignment operator,' the <- symbol, to assign a value to our specified object name. Here, we'll assign the previous calculation to an object that we are calling 'our_object'.

#There are some more baroque ways around this, but it's best to operate under the impression that object names cannot include spaces (or start with numbers). This kind of thing is common in some programming languages, so there are a couple stylistic conventions to address this. I tend to use what's called 'snake case,' which involves replacing spaces with underscores. There's also 'camel case,' where each word has the first letter capitalized, e.g. MyVariableName. I would settle on one that you like and be consistent with it.

our_object <- 5+2

#If you run this command, you should see 'our_object' populate in the upper-right Environment window. This is where you can find all of the objects that you manually specify in your R session. We can run the object itself, as well as combine it with other operations

our_object

our_object + 3

our_object * 100

#R is also useful for its implementation of functions, which you can think of in the sense you likely learned in your math classes. Functions are defined procedures that take some input value, transform that value according to the procedure, and then output a new value. 

#R comes with a great deal of already defined functions, and we can use these to perform all sorts of helpful operations. You can call a function by indicating it's common name and then placing it's required inputs between parentheses, e.g. function_name(input). We'll get a lot of mileage out of functions.

#Now, let's take a step back and think about some of our basic building blocks in R.

############################
#Vectors
############################

#You can think of vectors as ordered sets of values. We can use the c() function (short for 'combine') to create a vector made up of the values we provide. Let's make a few different vectors

interval_ratio_vec <- c(1.2, 3.4, 5.6, 7.1, 2.8)

ordinal_vec <- c("1-2", "5 or more", "1-2", "3-4", "5 or more") #When you want R to treat something as a character string (rather than as a command or an object of some kind), you place it in quotations.

nominal_vec <- c("east", "west", "south", "south", "north") 

logical_vec <- c(TRUE, FALSE, TRUE, FALSE, FALSE) #upper-case 'true' and 'false' have fixed values in R and, when used without quotes, will refer to these pre-defined logical values




#These 4 objects represent the different types of vectors that we'll most commonly encounter. Note that you may also see the term 'dbl' or 'double', for example:

typeof(interval_ratio_vec) # the typeof() function can be used to check what data-type a given object is

#The reason is a little esoteric, but just note that you can treat these 'double' or 'dbl' data-types as being numeric for our purposes.

#Numeric data will generally correspond with our interval-ratio variables. Numbers are usually processed as numeric type in R by default.

#Character data types will typically align with ordinal and nominal variables.

#We probably won't make much use of logical vectors for our analyses, but it's likely you'll run into them and they're one of the basic data types in R. They can be useful for a variety of data-sorting processes.

#Many R functions will respond differently to different data types, so it's important to keep these in mind when you need to troubleshoot errors.

#Take the mean() function, for example. As the name implies, this function will return the arithmetic mean of a numeric vector. Let's give it the one we just made above:
mean(interval_ratio_vec)

#Note that it gives the same response as if we had manually calculated it. Functions can make our lives a lot easier with larger amounts of data, but always make sure you're familiar with what's going on under the hood of any given function.
(1.2+3.4+5.6+7.1+2.8)/5

#But, what happens when we run the following command?
mean(nominal_vec)

#It doesn't make any sense to take the mean of the cardinal directions, so it will throw a warning message. We need a variable that can be represented numerically. Note that mean() also accepts logical variables, as, in R, TRUEs will be counted as 1s and FALSEs will be counted as 0s. In this case, you will be getting the proportion of true responses
mean(logical_vec)

(1+0+1+0+0)/5

##############
#Data Frames
##############

#For the most part, we will be working with data frames. These are collections of data organized in rows and columns. In data science, it's generally preferable for data to take a particular shape wherein each row indicates a single observation, and each column represents a unique variable. This is called the 'tidy' data format.

#Let's use the vectors we created above to mock up a little data frame. We will imagine some variables that those vectors could represent. First, let's make one more vector to use as a participant ID for hypothetical people in our data set. So, each of ours rows will represent variables measured for one person.

p_id_vec<-c("p1", "p2", "p3", "p4", "p5")

#Now, let's use a base R function to create a data frame and assign it to a new object

#As its input, data.frame() takes a list of vectors that must have the same number of items in them. These vectors will become our variables, where each item within them reflects a value for a different observation.

#The function and its input will take the form: data.frame(variable1_name = input_vector1, variable2_name = input_vector2, [...])

#We will make a data frame with 5 variables, and each variable column will be made up of the vectors that we just created above.

#We'll go ahead and imagine building a small data frame of dog owners.

our_df<-data.frame(
  p_id = p_id_vec, # a participant ID variable for each dog owner
  num_dogs = ordinal_vec, # a variable for the number of dogs each participant has
  side_of_town = nominal_vec, # the side of town each participant lives in
  food_per_day = interval_ratio_vec, # daily dog food amount in ounces
  has_a_labrador = logical_vec # a variable indicating whether a participant has a lab or not
)

#As a slight tangent, note that we can use line breaks to our advantage with longer strings of code. The above command is identical to the one below but is a little more intuitively readable. It's most important that your code works, so you don't have to organize it like that, but know that's an option

our_df <- data.frame(p_id = p_id_vec, num_dogs = ordinal_vec, side_of_town = nominal_vec, food_per_day = interval_ratio_vec, has_a_labrador = logical_vec)

#Take a look at our new data frame by clicking on the object in our Environment window at the upper right, or by running the following command. Both do the same thing
View(our_df)

#Once we have created a data frame, we can refer to individual variables with the $ operator in R
our_df$food_per_day

mean(our_df$food_per_day)

#Note that we can also use a bracket-based notation to access elements of an object. For data frames, the basic R syntax goes like this: data_frame[rows, columns]. Let's look at a couple examples.

#This will give us the value in the cell of the 3rd row, in the 2nd column. In other words, this will target the 3rd participant (3rd row) and tell us the number of dogs they own (2nd variable column). 
our_df[3,2]

#We can also leave one of the entries blank, which will tell R that we want to keep all the values of that type (row or column)

#Take the 2nd row but keep all columns
our_df[2,]

#Take the 3rd column but keep all rows
our_df[,3]

#To tie it together, note that the following two commands do exactly the same thing. With R, there are often a number of different ways to accomplish the same task, and learning to recognize these symmetries will help you become fluent in R over the long haul.
mean(our_df$food_per_day)
mean(our_df[,4])

#We can look at some basic characteristics of the data frame with the summary() function. Note that it will return different information depending on the data type of the variable
summary(our_df)

#Let's think about these for a second. 

#The summary of has_a_labrador makes sense. It's recognized as a logical vector and tells us the number of TRUEs and FALSEs

#food_per_day works as well. We're dealing with a continuous variable that allows for decimal places, so it makes sense to take the mean and look at the range and distribution.

#But how about side_of_town? We don't really want these values to be treated as 5 unrelated character strings. In this case, we have a nominal variable, where there's no mathematical relationship between categories (interval-ratio), and there's no meaningful order otherwise (ordinal). 

#In other words, when we have two entries of "south", we want those responses to be grouped together and not treated as unique entries.

#For this, we will want another key R data type.

###########
#Factors
###########

#Factors are often the best way to treat nominal and ordinal variables in R. Factors are a certain kind of vector that can only contain a number of pre-defined values. Each of these pre-defined values is considered a 'level' of the factor. So, we want side_of_town to be a factor variable with 4 levels: east, west, south, and north.

#We can turn this variable into a factor variable with base R's as.factor() function.
our_df$side_of_town <- as.factor(our_df$side_of_town)

#Check the summary() output again and notice how the output is reported now
summary(our_df)

#Now, let's think about num_dogs. This should clearly be a factor variable as well. But, unlike food_per_day, the levels of this variable have a very clear order, from 1-2 to 5 or more. 

#The factor() function allows us to turn a vector into a factor, as well as manually specify the levels. Additionally, we can activate a process in the function letting it know that we want the order to matter.


our_df$num_dogs <- factor(
  our_df$num_dogs, # the first input is the vector we are turning into a factor
  levels=c("1-2", "3-4", "5 or more"), # then we indicate the levels in the order that makes sense
  ordered = TRUE # and lastly we turn on a process that tells R that this order is important
  )



#Take a look back at the summary. Now, instead of 5 separate character strings, we can see the breakdown of how many people own a certain number of dogs.
summary(our_df)

#Note that the str() command is also useful for quickly gleaning the various data types of variable columns within a data frame. It will show us our variable names, the data types, and then a preview of the first several values in each variable column.

#We can also verify that num_dogs has been successfully re-coded as an ordered factor.

str(our_df)


#There are cases where you will want to convert a column like 'p_id' to a factor variable as well, but often we just need a variable like 'p_id' to serve as a searchable index for individual observations, so we can leave it be for now.

#This is all part of the process of data cleaning, where we make sure our data is structured in a fashion that's amenable to analysis. This re-coding of variables is an essential component, and we'll see plenty more tasks in this vein when we work with GSS data later on.

#For our last bit, let's learn a little bit about working with functions that don't come included in base R.


##################################
#R Packages and the tidyverse
##################################

#R's open-source culture has encouraged a rich ecosystem of custom functions designed by scientists and researchers in the R userbase. These come in the form of 'packages', which are suites of several related functions. For example, there are packages for conducting statistical tests, producing data visualizations, generating publication-ready tables, and all manner of other tasks. 

#Let's try this out with one of the better known R packages--'tidyverse'. This is actually a collection of several packages with a variety of interrelated functions for 'tidying', visualizing, and analyzing data. We will focus on what we need from 'tidyverse', but, if you're curious, you can read more here: https://www.tidyverse.org/


#If you're on a lab computer, this package may already be installed. Let's check by running the following command:
library(tidyverse)

#If you receive an error when you run this, you likely do not have the package installed on your system. This is also probably the case if you are on your personal device and only recently acquired R.

#If you got an error, run the following command:
install.packages("tidyverse")

#With a few exceptions, you will always install new packages in this fashion:         install.packages("package_name")

#After it's done installing, go back and run the library(tidyverse) command again. Note that you always need to do this for an added package. Whether you've had it for a while or just installed it, you need to load any outside package into your current session by placing its name in the library() function.
library(tidyverse)

#Let's try bringing in a data frame to play with a few tidyverse functions. We'll use the load() function to bring in a subset of the General Social Survey, which contains a few variables from the 2022 survey wave. Run the following command and select the file "gss_sub.rda"

#The file.choose() function will open up a file-explorer window that allows you to manually select an R data file to load in. We'll talk about some other ways to import data files using R syntax next time.

load(file.choose())

#Take a look at our data frame. 
View(gss_sub)

gss_sub$realrinc_r <- as.numeric(as.character(gss_sub$realrinc))
  
gss_sub$realrinc <- gss_sub$realrinc |>
  as.character() |>
  as.numeric()

gss_csv<-read.csv("C:/Users/selke/Desktop/Teaching/SOC 300 F 2025/gss_2022_sub.csv")

summary(gss_sub)

gss_two<-as.data.frame(gss_sub)

our_gss<-gss_csv

save(gss_csv, file="C:/Users/selke/Desktop/Teaching/SOC 300 F 2025/our_gss.rda")



#Let's use this subset to explore some tidyverse functionality.
sex_inc <- select(our_gss, id, sex, realrinc)

fem_inc <- filter(sex_inc, sex=="female")

mean_inc <- summarise(our_gss, "mean_inc"=mean(realrinc, na.rm=TRUE))

#The Pipe
mean_inc <- summarise(our_gss, "mean_inc"=mean(realrinc, na.rm=TRUE))

#Is equivalent to...

mean_inc <- our_gss |>
  summarise("mean_age" = mean(realrinc, na.rm=TRUE))

#This really opens things up for chaining commands together

sex_means <- our_gss |>
  select(id, sex, realrinc) |>
  group_by(sex) |>
  summarise("mean_inc" = mean(realrinc, na.rm=TRUE)) #|>
  #drop_na(sex)
  
save(our_gss, file="our_gss.rda")

#################################
#GSS Subsetting (not for class)
#################################
#Subset the data so that we can focus on a just a few variables of interest
cont_vars <- c("year", "id", "age")

cat_vars <- c("race", "sex", "realrinc", "educ", "partyid", "happy")

my_vars <- c(cont_vars, cat_vars)

gss_sub <- gss_2022 |>
  select(all_of(my_vars))

# Recode some of the data

#Make sure all missing data is coded as NA
gss_sub <- gss_sub |>
  mutate(across(everything(), haven::zap_missing))


#Recode categorical variables into factors
gss_sub <- gss_sub |>
  mutate(across(all_of(cat_vars), forcats::as_factor))         

gss_sub <- gss_sub |>
  filter(year==2022)


save(gss_sub, file="gss_sub.rda")



gss_sub$happy |>
  summary() |>
  barplot(
    main = "Happiness Distribution of GSS Respondents",
    xlab = "Response value"
  )

gss_sub$realrinc <- gss_sub$realrinc |>
  as.character() |>
  as.numeric()
  


gss_inc <- gss_sub |>
  group_by(sex) |>
  drop_na(realrinc) |>
  summarize(
    "mean_inc" = mean(realrinc)
  )

str(gss_sub)

gss_sub$realrinc<-as.numeric(gss_sub$realrinc)

