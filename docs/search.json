[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SOC 300: Introduction to R",
    "section": "",
    "text": "Preface\nWelcome to this introductory R tutorial for SOC 300.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "data_frames.html",
    "href": "data_frames.html",
    "title": "3  Data Frames",
    "section": "",
    "text": "For the most part, we will be working with data frames. These are collections of data organized in rows and columns. In data science, it’s generally preferable for data to take a particular shape wherein each row indicates a single observation, and each column represents a unique variable. This is called the ‘tidy’ data format.\nLet’s use the vectors we created above to mock up a little data frame. We will imagine some variables that those vectors could represent. First, let’s make one more vector to use as a participant ID for hypothetical people in our data set. So, each of ours rows will represent variables measured for one person.\n\np_id_vec&lt;-c(\"p1\", \"p2\", \"p3\", \"p4\", \"p5\")\n\nNow, let’s use a base R function to create a data frame and assign it to a new object\nAs its input, data.frame() takes a list of vectors that must have the same number of items in them. These vectors will become our variables, where each item within them reflects a value for a different observation.\nThe function and its input will take the form: data.frame(variable1_name = input_vector1, variable2_name = input_vector2, […])\nWe will make a data frame with 5 variables, and each variable column will be made up of the vectors that we just created in the last section.\nWe’ll go ahead and imagine building a small data frame of dog owners.\n\nour_df&lt;-data.frame(\n  p_id = p_id_vec, # a participant ID variable for each dog owner\n  num_dogs = ordinal_vec, # a variable for the number of dogs each participant has\n  side_of_town = nominal_vec, # the side of town each participant lives in\n  food_per_day = interval_ratio_vec, # daily dog food amount in ounces\n  has_a_labrador = logical_vec # a variable indicating whether a participant has a lab or not\n)\n\nAs a slight tangent, note that we can use line breaks to our advantage with longer strings of code. The above command is identical to the one below but is a little more intuitively readable. It’s most important that your code works, so you don’t have to organize it like that, but know that’s an option\n\nour_df &lt;- data.frame(p_id = p_id_vec, num_dogs = ordinal_vec, side_of_town = nominal_vec, food_per_day = interval_ratio_vec, has_a_labrador = logical_vec)\n\nTake a look at our new data frame by clicking on the object in our Environment window at the upper right, or by running the command View(our_df). I’ll call the str() function to show a preview of the data’s structure\nOnce we have created a data frame, we can refer to individual variables with the $ operator in R\n\nour_df$food_per_day\n\n[1] 1.2 3.4 5.6 7.1 2.8\n\nmean(our_df$food_per_day)\n\n[1] 4.02\n\n\nNote that we can also use a bracket-based notation to access elements of an object. For data frames, the basic R syntax goes like this: data_frame[rows, columns]. Let’s look at a couple examples.\nThis will give us the value in the cell of the 3rd row, in the 2nd column. In other words, this will target the 3rd participant (3rd row) and tell us the number of dogs they own (2nd variable column).\n\nour_df[3,2]\n\n[1] \"1-2\"\n\n\nWe can also leave one of the entries blank, which will tell R that we want to keep all the values of that type (row or column)\nTake the 2nd row but keep all columns\n\nour_df[2,]\n\n  p_id  num_dogs side_of_town food_per_day has_a_labrador\n2   p2 5 or more         west          3.4          FALSE\n\n\nTake the 3rd column but keep all rows\n\nour_df[,3]\n\n[1] \"east\"  \"west\"  \"south\" \"south\" \"north\"\n\n\nTo tie it together, note that the following two commands do exactly the same thing. With R, there are often a number of different ways to accomplish the same task, and learning to recognize these symmetries will help you become fluent in R over the long haul.\n\nmean(our_df$food_per_day) \n\n[1] 4.02\n\nmean(our_df[,4])\n\n[1] 4.02\n\n\nWe can look at some basic characteristics of the data frame with the summary() function. Note that it will return different information depending on the data type of the variable\n\nsummary(our_df)\n\n     p_id             num_dogs         side_of_town        food_per_day \n Length:5           Length:5           Length:5           Min.   :1.20  \n Class :character   Class :character   Class :character   1st Qu.:2.80  \n Mode  :character   Mode  :character   Mode  :character   Median :3.40  \n                                                          Mean   :4.02  \n                                                          3rd Qu.:5.60  \n                                                          Max.   :7.10  \n has_a_labrador \n Mode :logical  \n FALSE:3        \n TRUE :2        \n                \n                \n                \n\n\nLet’s think about these for a second.\nThe summary of has_a_labrador makes sense. It’s recognized as a logical vector and tells us the number of TRUEs and FALSEs\nfood_per_day works as well. We’re dealing with a continuous variable that allows for decimal places, so it makes sense to take the mean and look at the range and distribution.\nBut how about side_of_town? We don’t really want these values to be treated as 5 unrelated character strings. In this case, we have a nominal variable, where there’s no mathematical relationship between categories (interval-ratio), and there’s no meaningful order otherwise (ordinal).\nIn other words, when we have two entries of “south”, we want those responses to be grouped together and not treated as unique entries.\nFor this, we will want another key R data type.",
    "crumbs": [
      "Day 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "factors.html",
    "href": "factors.html",
    "title": "4  Factors",
    "section": "",
    "text": "Factors are often the best way to treat nominal and ordinal variables in R. Factors are a certain kind of vector that can only contain a number of pre-defined values. Each of these pre-defined values is considered a ‘level’ of the factor. So, we want side_of_town to be a factor variable with 4 levels: east, west, south, and north.\nWe can turn this variable into a factor variable with base R’s as.factor() function.\n\nour_df$side_of_town &lt;- as.factor(our_df$side_of_town)\n\nCheck the summary() output again and notice how the output is reported now\n\nsummary(our_df)\n\n     p_id             num_dogs         side_of_town  food_per_day \n Length:5           Length:5           east :1      Min.   :1.20  \n Class :character   Class :character   north:1      1st Qu.:2.80  \n Mode  :character   Mode  :character   south:2      Median :3.40  \n                                       west :1      Mean   :4.02  \n                                                    3rd Qu.:5.60  \n                                                    Max.   :7.10  \n has_a_labrador \n Mode :logical  \n FALSE:3        \n TRUE :2        \n                \n                \n                \n\n\nNow, let’s think about num_dogs. This should clearly be a factor variable as well. But, unlike food_per_day, the levels of this variable have a very clear order, from 1-2 to 5 or more.\nThe factor() function allows us to turn a vector into a factor, as well as manually specify the levels. Additionally, we can activate a process in the function letting it know that we want the order to matter.\n\nour_df$num_dogs &lt;- factor(\n  our_df$num_dogs, # the first input is the vector we are turning into a factor\n  levels=c(\"1-2\", \"3-4\", \"5 or more\"), # then we indicate the levels in the order that makes sense\n  ordered = TRUE # and lastly we turn on a process that tells R that this order is important\n  )\n\nTake a look back at the summary. Now, instead of 5 separate character strings, we can see the breakdown of how many people own a certain number of dogs.\n\nsummary(our_df)\n\n     p_id                num_dogs side_of_town  food_per_day  has_a_labrador \n Length:5           1-2      :2   east :1      Min.   :1.20   Mode :logical  \n Class :character   3-4      :1   north:1      1st Qu.:2.80   FALSE:3        \n Mode  :character   5 or more:2   south:2      Median :3.40   TRUE :2        \n                                  west :1      Mean   :4.02                  \n                                               3rd Qu.:5.60                  \n                                               Max.   :7.10                  \n\n\nNote that the str() command is also useful for quickly gleaning the various data types of variable columns within a data frame. It will show us our variable names, the data types, and then a preview of the first several values in each variable column.\nWe can also verify that num_dogs has been successfully re-coded as an ordered factor.\n\nstr(our_df)\n\n'data.frame':   5 obs. of  5 variables:\n $ p_id          : chr  \"p1\" \"p2\" \"p3\" \"p4\" ...\n $ num_dogs      : Ord.factor w/ 3 levels \"1-2\"&lt;\"3-4\"&lt;\"5 or more\": 1 3 1 2 3\n $ side_of_town  : Factor w/ 4 levels \"east\",\"north\",..: 1 4 3 3 2\n $ food_per_day  : num  1.2 3.4 5.6 7.1 2.8\n $ has_a_labrador: logi  TRUE FALSE TRUE FALSE FALSE\n\n\nThere are cases where you will want to convert a column like ‘p_id’ to a factor variable as well, but often we just need a variable like ‘p_id’ to serve as a searchable index for individual observations, so we can leave it be for now.\nThis is all part of the process of data cleaning, where we make sure our data is structured in a fashion that’s amenable to analysis. This re-coding of variables is an essential component, and we’ll see plenty more tasks in this vein when we work with GSS data later on.\nFor our last bit, let’s learn a little bit about working with functions that don’t come included in base R.",
    "crumbs": [
      "Day 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Factors</span>"
    ]
  },
  {
    "objectID": "objects_and_operations.html",
    "href": "objects_and_operations.html",
    "title": "1  Objects and Operations",
    "section": "",
    "text": "1.1 Basic Operations\nFirst, we will start by exploring some of the basic characteristics of R.\nR can be used as a simple calculator and will process both numbers and conventional mathematical operator symbols. You can run the commands below by placing your cursor at the beginning or end of the line and pressing CTRL+Enter (Windows) or Command+Return (Mac)\n5+2\n\n[1] 7\nYou should see the result displayed in the console below.",
    "crumbs": [
      "Day 1",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Objects and Operations</span>"
    ]
  },
  {
    "objectID": "vectors_and_data.html",
    "href": "vectors_and_data.html",
    "title": "2  Vectors and R Data Types",
    "section": "",
    "text": "You can think of vectors as ordered sets of values. We can use the c() function (short for ‘combine’) to create a vector made up of the values we provide. Let’s make a few different vectors\n\ninterval_ratio_vec &lt;- c(1.2, 3.4, 5.6, 7.1, 2.8)\n\nordinal_vec &lt;- c(\"1-2\", \"5 or more\", \"1-2\", \"3-4\", \"5 or more\") #When you want R to treat something as a character string (rather than as a command or an object of some kind), you place it in quotations.\n\nnominal_vec &lt;- c(\"east\", \"west\", \"south\", \"south\", \"north\") \n\nlogical_vec &lt;- c(TRUE, FALSE, TRUE, FALSE, FALSE) #upper-case 'true' and 'false' have fixed values in R and, when used without quotes, will refer to these pre-defined logical values\n\nThese 4 objects represent the different types of vectors that we’ll most commonly encounter. Note that you may also see the term ‘dbl’ or ‘double’, for example:\n\ntypeof(interval_ratio_vec) # the typeof() function can be used to check what data-type a given object is\n\n[1] \"double\"\n\n\nThe reason is a little esoteric, but just note that you can treat these ‘double’ or ‘dbl’ data-types as being numeric for our purposes.\nNumeric data will generally correspond with our interval-ratio variables. Numbers are usually processed as numeric type in R by default.\nCharacter data types will typically align with ordinal and nominal variables.\nWe probably won’t make much use of logical vectors for our analyses, but it’s likely you’ll run into them and they’re one of the basic data types in R. They can be useful for a variety of data-sorting processes.\nMany R functions will respond differently to different data types, so it’s important to keep these in mind when you need to troubleshoot errors.\nTake the mean() function, for example. As the name implies, this function will return the arithmetic mean of a numeric vector. Let’s give it the one we just made above:\n\nmean(interval_ratio_vec)\n\n[1] 4.02\n\n\nNote that it gives the same response as if we had manually calculated it. Functions can make our lives a lot easier with larger amounts of data, but always make sure you’re familiar with what’s going on under the hood of any given function.\n\n(1.2+3.4+5.6+7.1+2.8)/5\n\n[1] 4.02\n\n\nBut, what happens when we run the following command?\n\nmean(nominal_vec)\n\nWarning in mean.default(nominal_vec): argument is not numeric or logical:\nreturning NA\n\n\n[1] NA\n\n\nIt doesn’t make any sense to take the mean of the cardinal directions, so it will throw a warning message. We need a variable that can be represented numerically. Note that mean() also accepts logical variables, as, in R, TRUEs will be counted as 1s and FALSEs will be counted as 0s. In this case, you will be getting the proportion of true responses\n\nmean(logical_vec)\n\n[1] 0.4\n\n(1+0+1+0+0)/5\n\n[1] 0.4",
    "crumbs": [
      "Day 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Vectors and R Data Types</span>"
    ]
  },
  {
    "objectID": "objects_and_operations.html#storing-objects",
    "href": "objects_and_operations.html#storing-objects",
    "title": "1  Objects and Operations",
    "section": "1.2 Storing Objects",
    "text": "1.2 Storing Objects\nR is especially helpful for allowing us to create and store objects that we can call and manipulate later. We can create names for these objects and then use R’s ‘assignment operator,’ the &lt;- symbol, to assign a value to our specified object name. Here, we’ll assign the previous calculation to an object that we are calling ‘our_object’.\nThere are some more baroque ways around this, but it’s best to operate under the impression that object names cannot include spaces (or start with numbers). This kind of thing is common in some programming languages, so there are a couple stylistic conventions to address this. I tend to use what’s called ‘snake case,’ which involves replacing spaces with underscores. There’s also ‘camel case,’ where each word has the first letter capitalized, e.g. MyVariableName. I would settle on one that you like and be consistent with it.\n\nour_object &lt;- 5+2\n\nIf you run this command, you should see ‘our_object’ populate in the upper-right Environment window. This is where you can find all of the objects that you manually specify in your R session. We can run the object itself, as well as combine it with other operations\n\nour_object\n\n[1] 7\n\nour_object + 3\n\n[1] 10\n\nour_object * 100\n\n[1] 700",
    "crumbs": [
      "Day 1",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Objects and Operations</span>"
    ]
  },
  {
    "objectID": "objects_and_operations.html#a-note-on-functins",
    "href": "objects_and_operations.html#a-note-on-functins",
    "title": "1  Objects and Operations",
    "section": "1.3 A Note on Functins",
    "text": "1.3 A Note on Functins\nR is also useful for its implementation of functions, which you can think of in the sense you likely learned in your math classes. Functions are defined procedures that take some input value, transform that value according to the procedure, and then output a new value.\nR comes with a great deal of already defined functions, and we can use these to perform all sorts of helpful operations. You can call a function by indicating it’s common name and then placing it’s required inputs between parentheses, e.g. function_name(input). We’ll get a lot of mileage out of functions.\nNow, let’s take a step back and think about some of our basic building blocks in R.",
    "crumbs": [
      "Day 1",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Objects and Operations</span>"
    ]
  },
  {
    "objectID": "objects_and_operations.html#a-note-on-functions",
    "href": "objects_and_operations.html#a-note-on-functions",
    "title": "1  Objects and Operations",
    "section": "1.3 A Note on Functions",
    "text": "1.3 A Note on Functions\nR is also useful for its implementation of functions, which you can think of in the sense you likely learned in your math classes. Functions are defined procedures that take some input value, transform that value according to the procedure, and then output a new value.\nR comes with a great deal of already defined functions, and we can use these to perform all sorts of helpful operations. You can call a function by indicating it’s common name and then placing it’s required inputs between parentheses, e.g. function_name(input). We’ll get a lot of mileage out of functions.\nNow, let’s take a step back and think about some of our basic building blocks in R.",
    "crumbs": [
      "Day 1",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Objects and Operations</span>"
    ]
  }
]