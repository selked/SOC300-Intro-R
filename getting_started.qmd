# R Fundamentals

## Basic Operations
First, we will start by exploring some of the basic characteristics of R.

R can be used as a simple calculator and will process both numbers and conventional mathematical operator symbols. You can run the commands below by placing your cursor at the beginning or end of the line and pressing CTRL+Enter (Windows) or Command+Return (Mac)

```{r}         
5+2
```

You should see the result displayed in the console below.

## Storing Objects
R is especially helpful for allowing us to create and store objects that we can call and manipulate later. We can create names for these objects and then use R's 'assignment operator,' the \<- symbol, to assign a value to our specified object name. Here, we'll assign the previous calculation to an object that we are calling 'our_object'.

If you run this command on your own device, you should see 'our_object' populate in the upper-right Environment window. This is where you can find all of the objects that you create in your R session. We can run the object itself, as well as combine it with other operations

```{r}
our_object <- 5+2
```

There are some more baroque ways around this, but it's best to operate under the impression that object names cannot include spaces (or start with numbers). This kind of thing is common in some programming languages, so there are a couple stylistic conventions to address this. I tend to use what's called 'snake case,' which involves replacing spaces with underscores. There's also 'camel case,' where each word has the first letter capitalized, e.g. MyVariableName. I would settle on one that you like and be consistent with it.


```{r}
our_object

our_object + 3

our_object * 100
```

## A Note on Functions
R is also useful for its implementation of functions, which you can think of in the sense you likely learned in your math classes. Functions are defined procedures that take some input value, transform that value according to the procedure, and then output a new value.

R comes with a great deal of already defined functions, and we can use these to perform all sorts of helpful operations. You can call a function by indicating it's common name and then placing it's required inputs between parentheses, e.g. function_name(input). We'll get a lot of mileage out of functions.

Now, let's take a step back and think about some of our basic building blocks in R.

## Vectors and R Data Types

You can think of vectors as ordered sets of values. We can use the c() function (short for 'combine') to create a vector made up of the values we provide. Let's make a few different vectors

```{r}
interval_ratio_vec <- c(1.2, 3.4, 5.6, 7.1, 2.8)

ordinal_vec <- c("1-2", "5 or more", "1-2", "3-4", "5 or more") #When you want R to treat something as a character string (rather than as a command or an object of some kind), you place it in quotations.

nominal_vec <- c("east", "west", "south", "south", "north") 

logical_vec <- c(TRUE, FALSE, TRUE, FALSE, FALSE) #upper-case 'true' and 'false' have fixed values in R and, when used without quotes, will refer to these pre-defined logical values
```

These 4 objects represent the different types of vectors that we'll most commonly encounter. Note that you may also see the term 'dbl' or 'double', for example:

```{r}
typeof(interval_ratio_vec) # the typeof() function can be used to check what data-type a given object is
```

The reason is a little esoteric, but just note that you can treat these 'double' or 'dbl' data-types as being numeric for our purposes.

Numeric data will generally correspond with our interval-ratio variables. Numbers are usually processed as numeric type in R by default.

Character data types will typically align with ordinal and nominal variables.

We probably won't make much use of logical vectors for our analyses, but it's likely you'll run into them and they're one of the basic data types in R. They can be useful for a variety of data-sorting processes.

Many R functions will respond differently to different data types, so it's important to keep these in mind when you need to troubleshoot errors.

Take the mean() function, for example. As the name implies, this function will return the arithmetic mean of a numeric vector. Let's give it the one we just made above:

```{r}
mean(interval_ratio_vec)
```

Note that it gives the same response as if we had manually calculated it. Functions can make our lives a lot easier with larger amounts of data, but always make sure you're familiar with what's going on under the hood of any given function.

```{r}
(1.2+3.4+5.6+7.1+2.8)/5
```

But, what happens when we run the following command?

```{r}
mean(nominal_vec)
```

It doesn't make any sense to take the mean of the cardinal directions, so it will throw a warning message. We need a variable that can be represented numerically. Note that mean() also accepts logical variables, as, in R, TRUEs will be counted as 1s and FALSEs will be counted as 0s. In this case, you will be getting the proportion of true responses

```{r}
mean(logical_vec)

(1+0+1+0+0)/5
```

## Data Frames

For the most part, we will be working with data frames. These are collections of data organized in rows and columns. In data science, it's generally preferable for data to take a particular shape wherein each row indicates a single observation, and each column represents a unique variable. This is called the 'tidy' data format.

Let's use the vectors we created above to mock up a little data frame. We will imagine some variables that those vectors could represent. First, let's make one more vector to use as a participant ID for hypothetical people in our data set. So, each of ours rows will represent variables measured for one person.

```{r}
p_id_vec<-c("p1", "p2", "p3", "p4", "p5")
```

Now, let's use a base R function to create a data frame and assign it to a new object

As its input, data.frame() takes a list of vectors that must have the same number of items in them. These vectors will become our variables, where each item within them reflects a value for a different observation.

The function and its input will take the form: data.frame(variable1_name = input_vector1, variable2_name = input_vector2, \[...\])

We will make a data frame with 5 variables, and each variable column will be made up of the vectors that we just created in the last section.


We'll go ahead and imagine building a small data frame of dog owners.

```{r}
our_df<-data.frame(
  p_id = p_id_vec, # a participant ID variable for each dog owner
  num_dogs = ordinal_vec, # a variable for the number of dogs each participant has
  side_of_town = nominal_vec, # the side of town each participant lives in
  food_per_day = interval_ratio_vec, # daily dog food amount in ounces
  has_a_labrador = logical_vec # a variable indicating whether a participant has a lab or not
)
```

As a slight tangent, note that we can use line breaks to our advantage with longer strings of code. The above command is identical to the one below but is a little more intuitively readable. It's most important that your code works, so you don't have to organize it like that, but know that's an option

```{r}
our_df <- data.frame(p_id = p_id_vec, num_dogs = ordinal_vec, side_of_town = nominal_vec, food_per_day = interval_ratio_vec, has_a_labrador = logical_vec)
```

Take a look at our new data frame by clicking on the object in our Environment window at the upper right, or by running the command View(our_df). I'll call the str() function to show a preview of the data's **str**ucture

Once we have created a data frame, we can refer to individual variables with the \$ operator in R

```{r}
our_df$food_per_day

mean(our_df$food_per_day)
```

Note that we can also use a bracket-based notation to access elements of an object. For data frames, the basic R syntax goes like this: data_frame\[rows, columns\]. Let's look at a couple examples.

This will give us the value in the cell of the 3rd row, in the 2nd column. In other words, this will target the 3rd participant (3rd row) and tell us the number of dogs they own (2nd variable column).

```{r}
our_df[3,2]
```

We can also leave one of the entries blank, which will tell R that we want to keep all the values of that type (row or column)

Take the 2nd row but keep all columns

```{r}
our_df[2,]
```

Take the 3rd column but keep all rows

```{r}
our_df[,3]
```

To tie it together, note that the following two commands do exactly the same thing. With R, there are often a number of different ways to accomplish the same task, and learning to recognize these symmetries will help you become fluent in R over the long haul.

```{r}
mean(our_df$food_per_day) 
mean(our_df[,4])
```

We can look at some basic characteristics of the data frame with the summary() function. Note that it will return different information depending on the data type of the variable 
```{r}
summary(our_df)
```

Let's think about these for a second.

The summary of has_a_labrador makes sense. It's recognized as a logical vector and tells us the number of TRUEs and FALSEs

food_per_day works as well. We're dealing with a continuous variable that allows for decimal places, so it makes sense to take the mean and look at the range and distribution.

But how about side_of_town? We don't really want these values to be treated as 5 unrelated character strings. In this case, we have a nominal variable, where there's no mathematical relationship between categories (interval-ratio), and there's no meaningful order otherwise (ordinal).

In other words, when we have two entries of "south", we want those responses to be grouped together and not treated as unique entries.

For this, we will want another key R data type.

## Factors

Factors are often the best way to treat categorical variables (nominal or ordinal) in R. Factors are a certain kind of vector that can only contain a number of pre-defined values. Each of these pre-defined values is considered a 'level' of the factor. So, we want side_of_town to be a factor variable with 4 levels: east, west, south, and north.

We can turn this variable into a factor variable with base R's as.factor() function.

```{r}
our_df$side_of_town <- as.factor(our_df$side_of_town)
```

Check the summary() output again and notice how the output is reported now

```{r}
summary(our_df)
```

Now, let's think about num_dogs. This should clearly be a factor variable as well. But, unlike food_per_day, the levels of this variable have a very clear order, from 1-2 to 5 or more.

The factor() function allows us to turn a vector into a factor, as well as manually specify the levels. Additionally, we can activate a process in the function letting it know that we want the order to matter.

```{r}
our_df$num_dogs <- factor(
  our_df$num_dogs, # the first input is the vector we are turning into a factor
  levels=c("1-2", "3-4", "5 or more"), # then we indicate the levels in the order that makes sense
  ordered = TRUE # and lastly we turn on a process that tells R that this order is important
  )
```

Take a look back at the summary. Now, instead of 5 separate character strings, we can see the breakdown of how many people own a certain number of dogs.

```{r}
summary(our_df)
```

Note that the str() command is also useful for quickly gleaning the various data types of variable columns within a data frame. It will show us our variable names, the data types, and then a preview of the first several values in each variable column.

We can also verify that num_dogs has been successfully re-coded as an ordered factor.

```{r}
str(our_df)
```

There are cases where you will want to convert a column like 'p_id' to a factor variable as well, but often we just need a variable like 'p_id' to serve as a searchable index for individual observations, so we can leave it be for now.

This is all part of the process of data cleaning, where we make sure our data is structured in a fashion that's amenable to analysis. This re-coding of variables is an essential component, and we'll see plenty more tasks in this vein when we work with GSS data later on.

For our last bit, let's learn a little bit about working with functions that don't come included in base R.






