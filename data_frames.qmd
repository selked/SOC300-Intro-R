# Data Frames

For the most part, we will be working with data frames. These are collections of data organized in rows and columns. In data science, it's generally preferable for data to take a particular shape wherein each row indicates a single observation, and each column represents a unique variable. This is called the 'tidy' data format.

Let's use the vectors we created above to mock up a little data frame. We will imagine some variables that those vectors could represent. First, let's make one more vector to use as a participant ID for hypothetical people in our data set. So, each of ours rows will represent variables measured for one person.

```{r}
p_id_vec<-c("p1", "p2", "p3", "p4", "p5")
```

Now, let's use a base R function to create a data frame and assign it to a new object

As its input, data.frame() takes a list of vectors that must have the same number of items in them. These vectors will become our variables, where each item within them reflects a value for a different observation.

The function and its input will take the form: data.frame(variable1_name = input_vector1, variable2_name = input_vector2, \[...\])

We will make a data frame with 5 variables, and each variable column will be made up of the vectors that we just created in the last section.

```{r, echo=FALSE}
interval_ratio_vec <- c(1.2, 3.4, 5.6, 7.1, 2.8)

ordinal_vec <- c("1-2", "5 or more", "1-2", "3-4", "5 or more") #When you want R to treat something as a character string (rather than as a command or an object of some kind), you place it in quotations.

nominal_vec <- c("east", "west", "south", "south", "north") 

logical_vec <- c(TRUE, FALSE, TRUE, FALSE, FALSE) #upper-case 'true' and 'false' have fixed values in R and, when used without quotes, will refer to these pre-defined logical values
```

We'll go ahead and imagine building a small data frame of dog owners.

```{r}
our_df<-data.frame(
  p_id = p_id_vec, # a participant ID variable for each dog owner
  num_dogs = ordinal_vec, # a variable for the number of dogs each participant has
  side_of_town = nominal_vec, # the side of town each participant lives in
  food_per_day = interval_ratio_vec, # daily dog food amount in ounces
  has_a_labrador = logical_vec # a variable indicating whether a participant has a lab or not
)
```

As a slight tangent, note that we can use line breaks to our advantage with longer strings of code. The above command is identical to the one below but is a little more intuitively readable. It's most important that your code works, so you don't have to organize it like that, but know that's an option

```{r}
our_df <- data.frame(p_id = p_id_vec, num_dogs = ordinal_vec, side_of_town = nominal_vec, food_per_day = interval_ratio_vec, has_a_labrador = logical_vec)
```

Take a look at our new data frame by clicking on the object in our Environment window at the upper right, or by running the command View(our_df). I'll call the str() function to show a preview of the data's **str**ucture

Once we have created a data frame, we can refer to individual variables with the \$ operator in R

```{r}
our_df$food_per_day

mean(our_df$food_per_day)
```

Note that we can also use a bracket-based notation to access elements of an object. For data frames, the basic R syntax goes like this: data_frame\[rows, columns\]. Let's look at a couple examples.

This will give us the value in the cell of the 3rd row, in the 2nd column. In other words, this will target the 3rd participant (3rd row) and tell us the number of dogs they own (2nd variable column).

```{r}
our_df[3,2]
```

We can also leave one of the entries blank, which will tell R that we want to keep all the values of that type (row or column)

Take the 2nd row but keep all columns

```{r}
our_df[2,]
```

Take the 3rd column but keep all rows

```{r}
our_df[,3]
```

To tie it together, note that the following two commands do exactly the same thing. With R, there are often a number of different ways to accomplish the same task, and learning to recognize these symmetries will help you become fluent in R over the long haul.

```{r}
mean(our_df$food_per_day) 
mean(our_df[,4])
```

We can look at some basic characteristics of the data frame with the summary() function. Note that it will return different information depending on the data type of the variable 
```{r}
summary(our_df)
```

Let's think about these for a second.

The summary of has_a_labrador makes sense. It's recognized as a logical vector and tells us the number of TRUEs and FALSEs

food_per_day works as well. We're dealing with a continuous variable that allows for decimal places, so it makes sense to take the mean and look at the range and distribution.

But how about side_of_town? We don't really want these values to be treated as 5 unrelated character strings. In this case, we have a nominal variable, where there's no mathematical relationship between categories (interval-ratio), and there's no meaningful order otherwise (ordinal).

In other words, when we have two entries of "south", we want those responses to be grouped together and not treated as unique entries.

For this, we will want another key R data type.
