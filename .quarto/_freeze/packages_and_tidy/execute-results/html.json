{
  "hash": "da458a93adc602c80019851e407aedf5",
  "result": {
    "engine": "knitr",
    "markdown": "# Packages and the Tidyverse\n\nR's open-source culture has encouraged a rich ecosystem of custom functions designed by scientists and researchers in the R userbase. These come in the form of 'packages', which are suites of several related functions. For example, there are packages for conducting statistical tests, producing data visualizations, generating publication-ready tables, and all manner of other tasks.\n\n## Loading Packages\n\nLet's try this out with one of the better known R packages--'tidyverse'. This is actually a collection of several packages with a variety of interrelated functions for 'tidying', visualizing, and analyzing data. We will focus on what we need from 'tidyverse', but, if you're curious, you can read more here: <https://www.tidyverse.org/>\n\nIf you're on a lab computer, this package may already be installed. Let's check by running the following command:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\nIf you receive an error when you run this, you likely do not have the package installed on your system. This is also probably the case if you are on your personal device and only recently acquired R.\n\nIf you got an error, run the following command:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\n```\n:::\n\n\nWith a few exceptions, you will always install new packages in this fashion: install.packages(\"package_name\")\n\nAfter it's done installing, go back and run the library(tidyverse) command again. Note that you always need to do this for an added package. Whether you've had it for a while or just installed it, you need to load any outside package into your current session by placing its name in the library() function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n## Bringing in our Data\n\nLet's try bringing in a data frame to play with a few tidyverse functions. We'll use the `load()` function to bring in a subset of the General Social Survey, which contains a few variables from the 2022 survey wave. Run the following command and select the file \"our_gss.rda\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(file.choose())\n```\n:::\n\n\nThe `file.choose()` function will open up a file-explorer window that allows you to manually select an R data file to load in. We'll talk about some other ways to import data files using R syntax next time.\n\nGo ahead and take a look at the data frame. Each GSS survey wave has about 600-700 variables in total, so I've plucked several and done a little pre-processing to get us a subset to work with. All the variables here have pretty straightforward names, but I'll note that `realrinc` is a clear outlier there. This is short for 'Real respondent's income' and reflects the respondent's income reported in exact dollar amounts. I'll put a summary here so you can take a look if you're not following along with your own script.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(our_gss)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      year            id            age           race          sex      \n Min.   :2022   1      :   1   Min.   :18.00   white:2514   female:1897  \n 1st Qu.:2022   2      :   1   1st Qu.:34.00   other: 412   male  :1627  \n Median :2022   3      :   1   Median :48.00   black: 565   NA's  :  20  \n Mean   :2022   4      :   1   Mean   :49.18   NA's :  53                \n 3rd Qu.:2022   5      :   1   3rd Qu.:64.00                             \n Max.   :2022   6      :   1   Max.   :89.00                             \n                (Other):3538   NA's   :208                               \n    realrinc                                      partyid   \n Min.   :   204.5   independent (neither, no response):835  \n 1st Qu.:  8691.2   strong democrat                   :595  \n Median : 18405.0   not very strong democrat          :451  \n Mean   : 27835.3   strong republican                 :431  \n 3rd Qu.: 33742.5   independent, close to democrat    :400  \n Max.   :141848.3   (Other)                           :797  \n NA's   :1554       NA's                              : 35  \n           happy               marital                            attend    \n not too happy: 799   divorced     : 608   never                     :1149  \n pretty happy :1942   married      :1468   about once or twice a year: 464  \n very happy   : 779   never married:1095   every week                : 441  \n NA's         :  24   separated    : 103   less than once a year     : 416  \n                      widowed      : 255   several times a year      : 346  \n                      NA's         :  15   (Other)                   : 693  \n                                           NA's                      :  35  \n    cappun    \n favor :2013  \n oppose:1327  \n NA's  : 204  \n              \n              \n              \n              \n```\n\n\n:::\n:::\n\n\n## Data Wrangling with Tidyverse\n\nLet's use this subset to explore some tidyverse functionality. One of the packages included in the tidyverse is `dplyr`, which includes several functions for efficiently manipulating data frames in preparation for analyses. We will encounter a number of these throughout our time with R, but I want to briefly introduce a few key `dplyr` functions and operations that we will dig into more next time.\n\n### select()\n\nIt happens quite often that we have a data frame containing far more variables than we need for a given analysis. The `select()` function allows us to quickly subset data frames according to the variable columns we specify.\n\nThis function takes a data frame as its first input, and all following inputs are the variable columns that you want to keep\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsex_inc <- select(our_gss, id, sex, realrinc)\n```\n:::\n\n\nYou should now have an object that contains all 3,544 observations, but includes only the 3 columns that we specified with `select()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(sex_inc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       id           sex          realrinc       \n 1      :   1   female:1897   Min.   :   204.5  \n 2      :   1   male  :1627   1st Qu.:  8691.2  \n 3      :   1   NA's  :  20   Median : 18405.0  \n 4      :   1                 Mean   : 27835.3  \n 5      :   1                 3rd Qu.: 33742.5  \n 6      :   1                 Max.   :141848.3  \n (Other):3538                 NA's   :1554      \n```\n\n\n:::\n:::\n\n\n### filter()\n\n`filter()` functions similarly except that, instead of sub-setting by specific variables, it allows you to subset by specific values. So, let's take the `sex_inc` object we just created above. We now have this subset of three variables---id, sex, and income---but let's imagine we want to answer a question that's specific to women.\n\nIn order to do that, we need to *filter* the data to include only observations where the value of the variable `sex` is 'female'.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfem_inc <- filter(sex_inc, sex==\"female\")\n```\n:::\n\n\nNote that the `fem_inc` object still has 3 variables, but there are now roughly half the observations, suggesting that we have successfully filtered out the male observations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(fem_inc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       id           sex          realrinc       \n 1      :   1   female:1897   Min.   :   204.5  \n 3      :   1   male  :   0   1st Qu.:  7668.8  \n 4      :   1                 Median : 15337.5  \n 7      :   1                 Mean   : 22702.1  \n 9      :   1                 3rd Qu.: 27607.5  \n 10     :   1                 Max.   :141848.3  \n (Other):1891                 NA's   :883       \n```\n\n\n:::\n:::\n\n\n### summarize()\n\nAs the name suggests, `summarize()` allows us to quickly summarize information across variables. It will give us a new data frame that reflects the summaries that we ask for, which can be very useful for quickly generating descriptive statistics. We will use this to get the mean income value for our data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_inc <- summarize(our_gss, \"mean_inc\"=mean(realrinc, na.rm=TRUE))\n```\n:::\n\n\n::: callout-note\nYou probably noticed the `na.rm = TRUE` input that I supplied for the above function. This is short for 'remove NAs', which we need to do when a variable has any NA values. If we don't, R will screw up, because it does not know to disregard NA values when calculating a column mean unless we tell it to.\n:::\n\nThis gives us a new data frame that we called `mean_inc`. It should have 1 row and 1 column, and it just gives us the average income of a person in our GSS subset---about \\$28,000/year.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_inc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  mean_inc\n1 27835.33\n```\n\n\n:::\n:::\n\n\nNow, this is not really all that impressive when we are asking for a broad summary like this. In fact, if all we wanted was to see the average income, we could get that more easily, e.g.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(our_gss$realrinc, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 27835.33\n```\n\n\n:::\n:::\n\n\nThe true power of `summarize()` comes from chaining it together with other tidyverse functions. However, in order to do that, we will need to learn about one more new R operation. I'll show you that in a moment, but let's take a look at one more helpful tidyverse function.\n\n### group_by()\n\nOften when we're using a function like `summarize()`, we want to get summaries for all kinds of different subgroups within our data set. For example, we may want the mean for each value of `sex` or `partyid`, rather than for all people in the data frame. We can do this with `group_by`.\n\nThis function may seem a little unusual when used in isolation, because it does not seem to do much on the surface.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nour_gss <- group_by(our_gss, partyid)\n```\n:::\n\n\nWhen you run that function, you will not generate any new objects, and you will not notice anything different about the data frame.\n\nWhat it does is overlay a grouping structure on the data frame, which will in turn affect how other tidyverse functions operate.\n\nCompare the output of `summarize()` run on this grouped version of our data frame with the use of `summarize()` above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_inc <- summarize(\n  our_gss,\n  \"mean_inc\" = mean(realrinc, na.rm = TRUE)\n  )\n\nmean_inc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 2\n  partyid                            mean_inc\n  <fct>                                 <dbl>\n1 strong democrat                      30677.\n2 independent (neither, no response)   21570.\n3 not very strong republican           29101.\n4 not very strong democrat             31743.\n5 independent, close to democrat       27916.\n6 other party                          23891.\n7 independent, close to republican     26825.\n8 strong republican                    32376.\n9 <NA>                                 16922.\n```\n\n\n:::\n:::\n\n\nWe ran the same `summarize()` command as before, but now it reflects the grouping structure that we imposed.\n\n## The Pipe\n\nThis one might be a little unintuitive, so don't worry if it doesn't immediately click. We will continue to get plenty of practice with it over the next couple of sessions.\n\nThe pipe operator looks like this: `|>`. What it does is take whatever is to the left of the symbol and 'pipe' it into the function on the right-hand side. That probably sounds a little strange, so let's see some examples.\n\nWe'll refer back to our `summarize()` command from above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_inc <- summarize(our_gss, \"mean_inc\"=mean(realrinc, na.rm=TRUE))\n```\n:::\n\n\nThis is equivalent to...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_inc <- our_gss |>\n  summarize(\"mean_age\" = mean(realrinc, na.rm=TRUE))\n```\n:::\n\n\nNotice that, in the first command, the first input that we give `summarize()` is the data frame that we want it to work with.\n\nIn the command featuring the pipe operator, we supply the data frame and then pipe it into `summarize()`. The real magic comes from chaining multiple pipes together. This will likely take a little practice to get used to, but it can become a very powerful tool in our R arsenal.\n\n### Putting It All Together\n\nLet's illustrate with an example. I'll let you know what I want to do in plain English, and then I will execute that desire with multiple piped commands.\n\nUltimately, I want to see the mean income, but I want to see the mean broken down by `sex` and `partyid.`\n\nSo, I want to take a **selection** of variables from `our_gss`. I want these variables to be **grouped by** `sex` and `partyid`. Finally, I want to see a **summary** of the mean according to this variable grouping.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsexpol_means <- our_gss |>\n  select(id, sex, realrinc, partyid) |>\n  group_by(sex, partyid) |>\n  summarize(\"mean_inc\" = mean(realrinc, na.rm=TRUE)) |>\n  drop_na(sex, partyid)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n```\n\n\n:::\n:::\n\n\n::: callout-note\nWe can use `drop_na()` to do as the function's name suggests. When we learned about `group_by()` above, you may have noticed that a mean was reported for an `NA` category within the `partyid` variable. Any time you notice this and want your summaries to exclude these NA categories, just include that variable as an input to `drop_na()`.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsexpol_means\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 3\n# Groups:   sex [2]\n   sex    partyid                            mean_inc\n   <fct>  <fct>                                 <dbl>\n 1 female strong democrat                      30111.\n 2 female independent (neither, no response)   17923.\n 3 female not very strong republican           22448.\n 4 female not very strong democrat             24300.\n 5 female independent, close to democrat       19961.\n 6 female other party                          26595.\n 7 female independent, close to republican     20095.\n 8 female strong republican                    21584.\n 9 male   strong democrat                      31600.\n10 male   independent (neither, no response)   25474.\n11 male   not very strong republican           34544.\n12 male   not very strong democrat             41233.\n13 male   independent, close to democrat       36947.\n14 male   other party                          22450.\n15 male   independent, close to republican     31393.\n16 male   strong republican                    40210.\n```\n\n\n:::\n:::\n\n\nSo, using `dplyr`, we can quickly subset and manipulate data frames in just a few lines of relatively straightforward code. Here we have all the means for each value of `sex` and `partyid`, which would have been a tedious task had we calculated them all manually.\n\nWe will see plenty more on the tidyverse, so don't fret if you don't feel completely confident with these yet. It takes practice getting used to Rs peculiarities. We will keep building with these in the next unit and hopefully accumulate some muscle memory.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}