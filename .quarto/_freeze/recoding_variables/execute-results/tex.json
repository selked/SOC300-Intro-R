{
  "hash": "16110f96a88ffc6393a824d56cdccf8c",
  "result": {
    "engine": "knitr",
    "markdown": "# Recoding Variables\n\nToday's venture concerns univariate analysis, i.e. the quantitative description of a single variable. Before we do that, however, we need to familiarize ourselves with some data-cleaning procedures.\n\n## Background\n\nRecoding a variable involves manipulating the underlying structure of our variable such that we can use it for analysis. We did a little recoding during the last unit when we converted character vectors into factor variables. This allowed us to align R data types with the appropriate level of measurement.\n\nThere are also occasions when we need a variable to be translated from one level of measurement to another. For example, we may want to convert a ratio variable for \"number of years of education\" into an ordinal variable reflecting categories like \"less than high school\", \"high school diploma\", \"Associates degree\", and so on.\n\nWe may also want to collapse the categories of ordinal variables for some analyses. Consider a variable with a Likert-scale agreement rating, where you responses like \"strongly agree,\" \"moderately agree,\" \"slightly agree,\" and so forth. You may decide to collapse these categories into categories of \"Agree\" and \"Disagree\".\n\nWe will get some practice doing this sort of thing, which is an essential component of responsible analysis. Additionally, our next unit on bivariate analysis will require us to work with categorical variables in particular, so we need to be capable of converting any numeric variables.\n\n## Converting Numeric to Categorical\n\nWe will start by recoding `age`---a ratio variable---into an ordinal variable reflecting age groupings. The same strategies we use here will work for any numeric variable.\n\n### Setting up our workspace\n\nAs usual, let's make sure we load in `tidyverse` along with our GSS data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nload(\"our_gss.rda\")\n```\n:::\n\n\nLet's double check the structure of our data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(our_gss)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t3544 obs. of  11 variables:\n $ year    : num  2022 2022 2022 2022 2022 ...\n $ id      : Factor w/ 4149 levels \"1\",\"2\",\"3\",\"4\",..: 1 2 3 4 5 6 7 8 9 10 ...\n $ age     : num  72 80 57 23 62 27 20 47 31 72 ...\n $ race    : Factor w/ 3 levels \"white\",\"other\",..: 1 1 1 1 1 1 2 1 1 NA ...\n $ sex     : Factor w/ 2 levels \"female\",\"male\": 1 2 1 1 2 2 1 2 1 1 ...\n $ realrinc: num  40900 NA 18405 2250 NA ...\n $ partyid : Factor w/ 8 levels \"strong democrat\",..: 1 2 3 1 2 4 5 1 5 1 ...\n $ happy   : Ord.factor w/ 3 levels \"not too happy\"<..: 1 1 1 1 2 2 2 2 2 2 ...\n $ marital : Factor w/ 5 levels \"divorced\",\"married\",..: 1 2 1 3 3 3 3 2 3 3 ...\n $ attend  : Factor w/ 9 levels \"never\",\"less than once a year\",..: 3 3 1 5 3 1 2 2 1 8 ...\n $ cappun  : Factor w/ 2 levels \"favor\",\"oppose\": 2 1 1 2 2 2 2 2 1 NA ...\n```\n\n\n:::\n:::\n\n\n::: callout-note\nYou might notice the 'int' category, which is short for 'integer'. This is a subtype of numeric data in R. Variables that are exclusively whole numbers are often recorded in this way, but we can work with them in R just like we can other sorts of numbers\n:::\n\n### The 'age' variable\n\nWe can take a look at all the values of age (along with the \\# of respondents in each age category) using the `count()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount(our_gss, age)\n```\n:::\n\n\nHowever, I'm not going to display those results here, as it will be a particularly long table of values (with 70+ different ages). It's fine to run it---it won't crash R or anything---but it will it clutter up this page. Let's take this as a good opportunity to take advantage of the fact that we are using one of the better funded and well-organized surveys in all of social sciences. As such, there's extensive documentation about all of the variables measured for the GSS. [Go ahead and take a look at the age variable via the GSS Data Explorer](https://gssdataexplorer.norc.org/variables/53/vshow), which allows us to search for unique variables and view their response values, the specific question(s) that was asked on the survey, and several other variable characteristics.\n\nThe responses range from 18 - 89 (in addition to a few categories for non-response). However, note that there's something unique about value 89. It's not just 89 years of age, but 89 & older. This isn't a real issue for our purposes, but take this as encouragement to interface with the codebook of any publicly available data you use. There's some imprecision at the upper end of this variable, and that might not be obvious without referencing the codebook.\n\nFor the purposes of this exercise, let's go ahead and turn age into a simple categorical variable with 3 levels---older, middle age, and younger. I'm going to choose the range somewhat arbitrarily for now. We can use univariate analysis to inform our decision about how to break up a numeric variable, so we will revisit this idea again later on.\n\n-   **Younger** = 18 - 35\n-   **Middle Age** = 36 - 49\n-   **Older** = 50 and up\n\nAt the end of the day, what we need to do is 1.) create a new variable column 2.) populate that column with ordinal labels that correspond with each respondent's numeric age interval.\n\n### New columns with mutate()\n\nFirst, let's consider the `mutate()` function. This function takes a data frame and appends a new variable column. This new variable is the result of some calculation applied to an existing variable column.\n\nLet's look at an application fo `mutate()` to get a feel for it. Now, this wouldn't be the best idea for a couple reasons, but, as an illustration, let's say we wanted to convert our yearly income values to an hourly wage (assuming 40 hrs/week).\n\n`mutate()` takes a data frame as its input, and then we provide the name of our new variable column(s) along with the calculation for this new variable. Below, I use `mutate()` to create a new column called `hr_wage`. Then, I tell R that the `hr_wage` variable should be calculated by taking each person's income value and diving that by 52 weeks in a year, and then 40 hours in a week.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Without the pipe operator\nour_gss <- mutate(\n  our_gss,\n  hr_wage = (realrinc/52)/40\n  )\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# With the pipe operator\nour_gss <- our_gss |>\n  mutate(\n    hr_wage = (realrinc/52)/40\n  )\n```\n:::\n\n\nTake a look at your new data frame object. I'll show a summary here to verify that we got our new column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(our_gss)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      year            id            age           race          sex      \n Min.   :2022   1      :   1   Min.   :18.00   white:2514   female:1897  \n 1st Qu.:2022   2      :   1   1st Qu.:34.00   other: 412   male  :1627  \n Median :2022   3      :   1   Median :48.00   black: 565   NA's  :  20  \n Mean   :2022   4      :   1   Mean   :49.18   NA's :  53                \n 3rd Qu.:2022   5      :   1   3rd Qu.:64.00                             \n Max.   :2022   6      :   1   Max.   :89.00                             \n                (Other):3538   NA's   :208                               \n    realrinc                                      partyid   \n Min.   :   204.5   independent (neither, no response):835  \n 1st Qu.:  8691.2   strong democrat                   :595  \n Median : 18405.0   not very strong democrat          :451  \n Mean   : 27835.3   strong republican                 :431  \n 3rd Qu.: 33742.5   independent, close to democrat    :400  \n Max.   :141848.3   (Other)                           :797  \n NA's   :1554       NA's                              : 35  \n           happy               marital                            attend    \n not too happy: 799   divorced     : 608   never                     :1149  \n pretty happy :1942   married      :1468   about once or twice a year: 464  \n very happy   : 779   never married:1095   every week                : 441  \n NA's         :  24   separated    : 103   less than once a year     : 416  \n                      widowed      : 255   several times a year      : 346  \n                      NA's         :  15   (Other)                   : 693  \n                                           NA's                      :  35  \n    cappun        hr_wage        \n favor :2013   Min.   : 0.09832  \n oppose:1327   1st Qu.: 4.17849  \n NA's  : 204   Median : 8.84856  \n               Mean   :13.38237  \n               3rd Qu.:16.22236  \n               Max.   :68.19631  \n               NA's   :1554      \n```\n\n\n:::\n:::\n\n\nSo, we can use `mutate()` to add a new column that contains our recoded variable. We just need a way to specify a calculation that takes into account the specific intervals we want for our ordinal labels. For this, we need one more function.\n\n### Custom intervals with cut()\n\nWe can use the `cut()` function to specify the intervals we want for our age groupings, and then we will combine it with `mutate()` to generate our recoded age variable. Specifically, `cut()` takes our intervals and turns each of them into a level in a new factor variable.\n\nBut first, I want to give a little context on interval notation in mathematics. It will help us all be a little more precise when we talk about ranges, and it will also help us understand an input we need to provide for `cut()`.\n\n#### An aside on intervals\n\nIn mathematic terms, an interval is the set of all numbers in between two specified end points. In formal notation, these are indicated with the two endpoints placed in brackets, e.g \\[1,5\\] as the interval of 1 through 5.\n\nThere are some technical terms to describe whether or not we want to include the endpoints when we are talking about a particular interval.\n\n-   **Closed interval**: This is when both end points are included in the interval. Closedness is indicated with square brackets, so, the closed interval of 1 through 5 would be written just like I have above---\\[1,5\\]. This indicates any number $x$ where $1 \\leq x \\leq 5$\n\n-   **Open interval**: This is when neither endpoint is included in the interval. In interval notation, openness is indicated with parentheses rather than square brackets, so the open interval of 1 through 5 would be written as (1,5). This interval would indicate any number $x$ where $1 < x < 5$\n\n-   **Left-open interval**: This is when the left-hand endpoint is not included, but the right-hand endpoint is. This would be written as (1,5\\] in interval notation, and that interval would indicate any number $x$ where $1 < x \\leq 5$\n\n-   **Right-open interval**: When the right-hand endpoint isn't included but the left endpoint is, you have a right-open interval. This would be written as \\[1,5) in interval notation and would indicate any number $x$ where $1 \\leq x < 5$.\n\nWe will be working with the right-open interval format, and we can specify that in `cut()`.\n\nNow, let's return to our task at hand.\n\n#### Inputs for cut()\n\nWe'll go ahead and work with cut directly in `mutate()`, as its going to be the calculation that we are providing for the new column we generate with `mutate()`.\n\nAs a reminder, here are the intervals we need:\n\n-   **Younger** = 18 - 35\n-   **Middle Age** = 36 - 49\n-   **Older** = 50 and up\n\nThe following code may look a little chaotic at first glance, but it's really the same sort of thing that we did with `mutate()` above. It's just that `cut()` is a little bit more involved of a calculation than the simple division we did in our example.\n\nJust like above, we are applying `mutate()` to `our_gss`, and we are giving the name of our new variable column (`age_ord`, in this case) as the first input. Then, for the calculation, we give the `cut()` function and the arguments it needs.\n\n**cut() and its inputs**\n\n-   The variable for which we want to specify intervals (`age`)\n\n-   **breaks**: This is where we indicate the intervals. The first number we give is the low end of our lowest age group (18). The second number is the low end of our middle age group (36). The third number, as you probably guessed, is the low end of our highest age group. The last value should reflect our upper limit. In this case, I use the value `Inf`, which is short for 'infinity'. This essentially tells R that the last category can include any values higher than the previous number we entered.\n\n-   **include.lowest**: Putting `TRUE` here tells R that, in each interval, we want the lowest value to be included. If we don't do this, then our 'younger' age grouping would be 19 - 35 rather than 18 - 35. In other words, setting this to `TRUE` indicates a left-closed interval, and `FALSE` indicates a left-open interval.\n\n-   **right**: This is the input for specifying whether we want this to be a right-closed interval, and it takes a logical value (`TRUE` or `FALSE`). We want a right-open interval, so we will set this to `FALSE`.\n\n-   **labels**: R will actually default to formal interval notation for the names of each level of our new factor variable, so it would be \\[18,36), \\[36,50), \\[50, Inf). However, we can provide a character vector to specify custom labels for these new factor levels. In the event that you have an ordinal variable, make sure that you always specify these labels in ascending order. In this case, that would be Younger \\< Middle Age \\< Older.\n\n-   **ordered_result**: This takes a logical value and, as the name suggests, indicates whether we want the factor to be ordered or not. In our case, there is a clear progression in terms of age, so we need to set this to `TRUE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nour_gss <- our_gss |>\n  mutate(\n    age_ord = cut(\n      age,\n      breaks = c(18, 36, 50, Inf),\n      include.lowest = TRUE,\n      right = FALSE,\n      labels = c(\"Younger\", \"Middle Age\", \"Older\"),\n      ordered_result = TRUE\n    )\n  )\n```\n:::\n\n\nGo ahead and take a look at `our_gss`, and we should now have an additional variable column. I'll use the `str()` function here so we can confirm that our factor was ordered and added to the data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(our_gss)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t3544 obs. of  13 variables:\n $ year    : num  2022 2022 2022 2022 2022 ...\n $ id      : Factor w/ 4149 levels \"1\",\"2\",\"3\",\"4\",..: 1 2 3 4 5 6 7 8 9 10 ...\n $ age     : num  72 80 57 23 62 27 20 47 31 72 ...\n $ race    : Factor w/ 3 levels \"white\",\"other\",..: 1 1 1 1 1 1 2 1 1 NA ...\n $ sex     : Factor w/ 2 levels \"female\",\"male\": 1 2 1 1 2 2 1 2 1 1 ...\n $ realrinc: num  40900 NA 18405 2250 NA ...\n $ partyid : Factor w/ 8 levels \"strong democrat\",..: 1 2 3 1 2 4 5 1 5 1 ...\n $ happy   : Ord.factor w/ 3 levels \"not too happy\"<..: 1 1 1 1 2 2 2 2 2 2 ...\n $ marital : Factor w/ 5 levels \"divorced\",\"married\",..: 1 2 1 3 3 3 3 2 3 3 ...\n $ attend  : Factor w/ 9 levels \"never\",\"less than once a year\",..: 3 3 1 5 3 1 2 2 1 8 ...\n $ cappun  : Factor w/ 2 levels \"favor\",\"oppose\": 2 1 1 2 2 2 2 2 1 NA ...\n $ hr_wage : num  19.66 NA 8.85 1.08 NA ...\n $ age_ord : Ord.factor w/ 3 levels \"Younger\"<\"Middle Age\"<..: 3 3 3 1 3 1 1 2 1 3 ...\n```\n\n\n:::\n:::\n\n\n## Restructuring Categorical Variables\n\nNow, let's go ahead and tackle the other recoding situation I mentioned up at the top---collapsing the levels of categorical variables. We'll work with `partyid` here, but the logic of this process will apply to any categorical variable.\n\n### Collapsing categories\n\nI encourage you to take a look at `partyid` in [the GSS Data Explorer, like we did for 'age'.](https://gssdataexplorer.norc.org/variables/141/vshow).\n\nBecause `partyid` is a categorical variable, it has far fewer unique values than a ratio variable like `age`, so we can go ahead and take a look at all of its levels with the `count()` function.\n\n::: callout-note\nObserve that `count(our_gss, partyid)` basically provides the same information as `summary(our_gss$partyid)` when the variable is a factor. The only real difference is that `count()` organizes the info into a tidy data frame. In other words, you can use either function to take a look at factor variable like this.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount(our_gss, partyid)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                             partyid   n\n1                    strong democrat 595\n2 independent (neither, no response) 835\n3         not very strong republican 361\n4           not very strong democrat 451\n5     independent, close to democrat 400\n6                        other party 106\n7   independent, close to republican 330\n8                  strong republican 431\n9                               <NA>  35\n```\n\n\n:::\n:::\n\n\nLet's go ahead and collapse these into categories of \"Democrat\", \"Independent\", \"Other Party\", and \"Republican\". We'll use `mutate()` to make a new variable column called `partyid_recoded`. For the calculation of our new variable, we can use the `fct_collapse()` function. This function allows us to first give the name of a new factor level, and then we can give a character vector of the names of levels that want to be collapses into a single category.\n\nSo, to collapse our 2 Democrat levels into a single factor level, we would give the following input for `fct_collapse()`:\n\n`\"Democrat\" = c(\"strong democrat\", \"not very strong democrat\")`\n\nAnd then repeat for each new factor level.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nour_gss <- our_gss |>\n  mutate(\n    partyid_recoded=fct_collapse(partyid, \n\"Democrat\" = c(\"strong democrat\", \"not very strong democrat\"),\n\"Republican\" = c(\"strong republican\",\"not very strong republican\"),\n\"Independent\" = c(\"independent, close to democrat\", \"independent (neither, no response)\", \"independent, close to republican\"),\n\"Other Party\" = c(\"other party\")\n))\n```\n:::\n\n\nNow, let's take a look at our new variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount(our_gss, partyid_recoded)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  partyid_recoded    n\n1        Democrat 1046\n2     Independent 1565\n3      Republican  792\n4     Other Party  106\n5            <NA>   35\n```\n\n\n:::\n:::\n\n\n### Excluding levels\n\nYou may also want to work with an existing categorical variable, but only focus on certain values. In this case, we can create a recoded variable and simply code the levels we are uninterested in as `NA`.\n\nWe can use the `fct_recode()` function for this. For the first input, we will give it the factor-variable column that we want to recode. Then, we will let it know that we want to set the levels of \"Other Party\" and \"Independent\" to `NULL`. This will convert them to NAs and allow us to easily exclude them from our analyses. We will use `fct_recode()` within `mutate()` so we can create another recoded version of `partyid_recoded`. We'll call this one `dem_rep` to distinguish it from the original `partyid` and our first recoded version.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nour_gss <- our_gss |>\n  mutate(dem_rep = fct_recode(\n    partyid_recoded, \n    NULL = \"Other Party\", \n    NULL = \"Independent\"))\n```\n:::\n\n\nLet's check to see that it worked.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount(our_gss, dem_rep)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     dem_rep    n\n1   Democrat 1046\n2 Republican  792\n3       <NA> 1706\n```\n\n\n:::\n:::\n\n\nNow that we have gotten all this pre-processing stuff out of the way, let's go ahead and dig into some univariate analysis.\n",
    "supporting": [
      "recoding_variables_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}