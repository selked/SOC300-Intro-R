{
  "hash": "48293a668d8da06c4653810b8b0143c7",
  "result": {
    "engine": "knitr",
    "markdown": "# Data Frames\n\nFor the most part, we will be working with data frames. These are collections of data organized in rows and columns. In data science, it's generally preferable for data to take a particular shape wherein each row indicates a single observation, and each column represents a unique variable. This is called the 'tidy' data format.\n\nLet's use the vectors we created above to mock up a little data frame. We will imagine some variables that those vectors could represent. First, let's make one more vector to use as a participant ID for hypothetical people in our data set. So, each of ours rows will represent variables measured for one person.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_id_vec<-c(\"p1\", \"p2\", \"p3\", \"p4\", \"p5\")\n```\n:::\n\n\n\n\n\n\n\n\nNow, let's use a base R function to create a data frame and assign it to a new object\n\nAs its input, data.frame() takes a list of vectors that must have the same number of items in them. These vectors will become our variables, where each item within them reflects a value for a different observation.\n\nThe function and its input will take the form: data.frame(variable1_name = input_vector1, variable2_name = input_vector2, \\[...\\])\n\nWe will make a data frame with 5 variables, and each variable column will be made up of the vectors that we just created in the last section.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n\nWe'll go ahead and imagine building a small data frame of dog owners.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nour_df<-data.frame(\n  p_id = p_id_vec, # a participant ID variable for each dog owner\n  num_dogs = ordinal_vec, # a variable for the number of dogs each participant has\n  side_of_town = nominal_vec, # the side of town each participant lives in\n  food_per_day = interval_ratio_vec, # daily dog food amount in ounces\n  has_a_labrador = logical_vec # a variable indicating whether a participant has a lab or not\n)\n```\n:::\n\n\n\n\n\n\n\n\nAs a slight tangent, note that we can use line breaks to our advantage with longer strings of code. The above command is identical to the one below but is a little more intuitively readable. It's most important that your code works, so you don't have to organize it like that, but know that's an option\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nour_df <- data.frame(p_id = p_id_vec, num_dogs = ordinal_vec, side_of_town = nominal_vec, food_per_day = interval_ratio_vec, has_a_labrador = logical_vec)\n```\n:::\n\n\n\n\n\n\n\n\nTake a look at our new data frame by clicking on the object in our Environment window at the upper right, or by running the command View(our_df). I'll call the str() function to show a preview of the data's **str**ucture\n\nOnce we have created a data frame, we can refer to individual variables with the \\$ operator in R\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nour_df$food_per_day\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.2 3.4 5.6 7.1 2.8\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(our_df$food_per_day)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.02\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nNote that we can also use a bracket-based notation to access elements of an object. For data frames, the basic R syntax goes like this: data_frame\\[rows, columns\\]. Let's look at a couple examples.\n\nThis will give us the value in the cell of the 3rd row, in the 2nd column. In other words, this will target the 3rd participant (3rd row) and tell us the number of dogs they own (2nd variable column).\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nour_df[3,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1-2\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nWe can also leave one of the entries blank, which will tell R that we want to keep all the values of that type (row or column)\n\nTake the 2nd row but keep all columns\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nour_df[2,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  p_id  num_dogs side_of_town food_per_day has_a_labrador\n2   p2 5 or more         west          3.4          FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nTake the 3rd column but keep all rows\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nour_df[,3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"east\"  \"west\"  \"south\" \"south\" \"north\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nTo tie it together, note that the following two commands do exactly the same thing. With R, there are often a number of different ways to accomplish the same task, and learning to recognize these symmetries will help you become fluent in R over the long haul.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(our_df$food_per_day) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.02\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(our_df[,4])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.02\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nWe can look at some basic characteristics of the data frame with the summary() function. Note that it will return different information depending on the data type of the variable \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(our_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     p_id             num_dogs         side_of_town        food_per_day \n Length:5           Length:5           Length:5           Min.   :1.20  \n Class :character   Class :character   Class :character   1st Qu.:2.80  \n Mode  :character   Mode  :character   Mode  :character   Median :3.40  \n                                                          Mean   :4.02  \n                                                          3rd Qu.:5.60  \n                                                          Max.   :7.10  \n has_a_labrador \n Mode :logical  \n FALSE:3        \n TRUE :2        \n                \n                \n                \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nLet's think about these for a second.\n\nThe summary of has_a_labrador makes sense. It's recognized as a logical vector and tells us the number of TRUEs and FALSEs\n\nfood_per_day works as well. We're dealing with a continuous variable that allows for decimal places, so it makes sense to take the mean and look at the range and distribution.\n\nBut how about side_of_town? We don't really want these values to be treated as 5 unrelated character strings. In this case, we have a nominal variable, where there's no mathematical relationship between categories (interval-ratio), and there's no meaningful order otherwise (ordinal).\n\nIn other words, when we have two entries of \"south\", we want those responses to be grouped together and not treated as unique entries.\n\nFor this, we will want another key R data type.\n",
    "supporting": [
      "data_frames_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}